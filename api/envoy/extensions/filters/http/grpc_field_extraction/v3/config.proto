syntax = "proto3";

package envoy.extensions.filters.http.grpc_field_extraction.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_field_extraction.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_field_extraction/v3;grpc_field_extractionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC Field Extraction]
// gRPC Field Extraction :ref:`configuration overview
// <config_http_filters_grpc_field_extraction>`.
// [#extension: envoy.filters.http.grpc_field_extraction]

// GrpcFieldExtractionConfig supports extracting the fields from first gRPC
// request message no matter if it is unary or streaming and inject the result
// in headers. It will **block headers propagation** before the extraction
// is done, so that the following filters can use the extraction result in headers. No op if isn't a gRPC
// method or its type cannot be found in the proto descriptor.
//
// The target field should be singular primitive type or repeated primitive
// type and its value will be extracted in string format.
//
//
// The output is a serialized google.protobuf.Struct of field<StringValue> -> extract values<ListValue of StringValue>. It will be injected in the `header` with base64 encoded format.
//
// For example, we have the following request definition for the gRPC method `/pkg.svc/Method`.
//
// message MethodRequest {
//   string foo = 1;
//   Nested nested = 2;
//   repeated int32 method baz = 3;
//   ...
// }
//
// message Nested {
//  string bar = 2;
// }
//
// This is the filter config(expressed in JSON format).
// {
//   "proto_descriptor_bin":{...},
//   "extractions_by_method": {
//      "/pkg.svc/Method":{
//         "request_field_extractions":{
//            "foo":{
//               "header":"grpc-field-extraction-output1-bin"
//            },
//            "nested.bar":{
//               "header":"grpc-field-extraction-output1-bin"
//            }
//            "baz":{
//               "header":"grpc-field-extraction-output2-bin"
//            }
//         }
//      }
//   },
//   ...
// }
//
//
// During runtime, the filter receives the following `MethodRequest` message(expressed in JSON format).
// {
//   foo: "val_foo",
//   nested: { "bar": ""val_bar"},
//   baz: [123, 456]
// }
//
// The filter will injects the following 2 request headers(expressed in JSON format).
//
// rpc-field-extraction-output1-bin: {
//   "foo":[
//      "val_foo"
//   ],
//   "nested.bar":[
//      "val_bar"
//   ]
// }
// rpc-field-extraction-output2-bin: {
//   "baz":[
//      "123",
//      "456"
//   ]
// }

message GrpcFieldExtractionConfig {
  // DescriptorSet is in local data source. It could be either in a local file or embedded in the
  // inline_bytes.
  config.core.v3.DataSource descriptor_set = 1 [(validate.rules).message = {required: true}];

  // Specify the extraction info.
  // The key is the fully qualified gRPC method name.
  // `/$package.$Service/$Method`, like
  // `/endpoints.examples.bookstore.BookStore/GetShelf`
  //
  // The value is the field extractions for individual gRPC method.
  map<string, FieldExtractions> extractions_by_method = 2;
}

// This message can be used to support per route config approach later even
// though the Istio doesn't support that so far.
message FieldExtractions {
  // The field extractions for requests.
  // The key is the field path within the grpc request.
  // For example, we can define `foo.bar.name` if we want to extract
  // Request.foo.bar.name.
  // message Request {
  //   // The namespace in which the Workspace should be created.
  //   Foo foo = 1;
  // }
  //
  // message Foo {
  //   Bar bar = 1;
  // }
  // message Bar {
  //   string name = 1;
  // }
  map<string, RequestFieldExtraction> request_field_extractions = 1;
}

message RequestFieldExtraction {
  oneof destination {
    // The name of the header the result will be injected into.
    // Extraction results with the same header name will be grouped.
    string request_header = 1;
  }
}
