syntax = "proto3";

package envoy.config.filter.http.header_to_metadata.v2;

option java_outer_classname = "HeaderToMetadataProto";
option java_multiple_files = true;
option java_package = "io.envoyproxy.envoy.config.filter.http.header_to_metadata.v2";
option go_package = "v2";

import "validate/validate.proto";

// [#protodoc-title: Header-To-Metadata Filter]
//
// The configuration for transforming between headers and metadata. This is useful
// for matching load balancer subsets, logging, sharing metadata across Envoys, etc.
//
// Header to Metadata :ref:`configuration overview <config_http_filters_header_to_metadata>`.

message Config {
  enum ValueType {
    STRING = 0;
    NUMBER = 1;

    // The value is a serialized `protobuf.Value
    // <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    PROTOBUF_VALUE = 2;
  }

  // ValueEncode defines the encoding algorithm.
  enum ValueEncode {
    // The value is not encoded.
    NONE = 0;

    // The value is encoded in `Base64 <https://tools.ietf.org/html/rfc4648#section-4>`_.
    // Note: this is mostly used for STRING and PROTOBUF_VALUE to escape the
    // non-ASCII characters in the header.
    BASE64 = 1;
  }

  message KeyValuePair {
    // The namespace — if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string.min_bytes = 1];

    // The value to pair with the given key.
    //
    // When used for a `on_header_present` case, if value is non-empty it'll be used
    // instead of the header value. If both are empty, no metadata is added.
    //
    // When used for a `on_header_missing` case, a non-empty value must be provided
    // otherwise no metadata is added.
    string value = 3;

    // The value's type — defaults to string.
    ValueType type = 4;

    // How is the value encoded, default is NONE (not encoded).
    // The value will be decoded accordingly before storing to metadata.
    ValueEncode encode = 5;
  }

  // A Rule defines what metadata to apply when a header is present or missing.
  message Rule {
    // The header that triggers this rule — required.
    string header = 1 [(validate.rules).string.min_bytes = 1];

    // If the header is present, apply this metadata KeyValuePair.
    //
    // If the value in the KeyValuePair is non-empty, it'll be used instead
    // of the header value.
    KeyValuePair on_header_present = 2;

    // If the header is not present, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set, since it'll be used in lieu
    // of the missing header value.
    KeyValuePair on_header_missing = 3;

    // Whether or not to remove the header after a rule is applied.
    //
    // This prevents headers from leaking.
    bool remove = 4;
  }

  // The list of rules to apply to requests. Use request_rules_v2 instead.
  repeated Rule request_rules = 1 [deprecated = true];

  // The list of rules to apply to responses. Use response_rules_v2 instead.
  repeated Rule response_rules = 2 [deprecated = true];

  // A Header defines where to find a HTTP header.
  message Header {
    // The name of the HTTP header.
    string name = 1 [(validate.rules).string.min_bytes = 1];

    // Whether or not to remove the header after a rule is applied. This only
    // has effect when used in source.
    //
    // This prevents headers from leaking.
    bool remove = 2;
  }

  // A Metadata defines where to find a metadata value.
  message Metadata {
    // The namespace of the Metadata.
    // - if this is empty, the filter's namespace will be used.
    // - if this is "node", the envoy node metadata will be used.
    string namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string.min_bytes = 1];

    // The metadata value's type — defaults to string.
    ValueType type = 3;
  }

  // A ToDestination defines how to copy a value to the destination.
  message ToDestination {
    // The destination that the value should be copied to.
    oneof destination {
      option (validate.required) = true;

      // Destination in HTTP header.
      Header header = 1;

      // Destination in metadata.
      // Note: node metadata in destination is not supported.
      Metadata metadata = 2;
    }

    // A constant value to copy to the destination.
    //
    // When used for a `on_source_present` case, if value is non-empty it'll be used
    // instead of the source. If both are empty, nothing will be copied to the destination.
    //
    // When used for a `on_source_missing` case, a non-empty value must be provided
    // otherwise nothing will be copied to the destination.
    string value = 3;

    // Decode the value before copying to the destination, default is NONE (not decoded).
    // This happens before encode (if present).
    ValueEncode decode = 4;

    // Encode the value before copying to the destination, default is NONE (not encoded).
    // This happens after decode (if present).
    ValueEncode encode = 5;
  }

  // A RuleV2 defines what ToDestination to apply when a source is present or missing.
  message RuleV2 {
    // The source that triggers this rule - required.
    oneof source {
      option (validate.required) = true;

      // Source value from the HTTP header.
      Header header = 1;

      // Source value from metadata.
      Metadata metadata = 2;
    }

    // If the source is present, apply the ToDestination.
    //
    // If the value in the ToDestination is non-empty, it'll be used instead
    // of the source.
    ToDestination on_source_present = 3;

    // If the source is not present, apply the ToDestination.
    //
    // The value in the ToDestination must be set, since it'll be used in lieu
    // of the missing source.
    ToDestination on_source_missing = 4;
  }

  // The list of V2 rules to apply to requests.
  repeated RuleV2 request_rules_v2 = 3;

  // The list of V2 rules to apply to responses.
  repeated RuleV2 response_rules_v2 = 4;
}
