syntax = "proto3";

package envoy.extensions.io.io_uring.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.io.io_uring.v3";
option java_outer_classname = "IoUringProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/io/io_uring/v3;io_uringv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: ``io_uring`` configuration]

// Configuration for an IO interface that relies on Linux specific ``io_uring`` API.
message IoUring {
  // The size of both submission and completion queues in queue entries. For heavily loaded
  // processes 300 queue entries is a good enough value. If the load is not high and memory
  // is a constraint then it's safe to have smaller queues. If not set, defaults to 300
  // queue entries.
  google.protobuf.UInt32Value io_uring_size = 1 [(validate.rules).uint32 = {gte: 2}];

  // When this flag is specified, a kernel thread is created to perform submission queue
  // polling. An ``io_uring`` instance configured in this way enables ``io_uring`` sockets to
  // issue I/O without ever context switching into the kernel and with better latency.
  //
  // Please note that the polling kernel thread will waste CPU cycles after the ``io_uring``
  // instance becomes inactive for a grace period which is set to 1 second currently. The
  // polling kernel thread will be started automatically as soon as the ``io_uring`` instance
  // becomes active again.
  bool use_submission_queue_polling = 2;
}
