syntax = "proto3";

package envoy.admin.v2alpha;

option java_outer_classname = "ConfigDumpProto";
option java_multiple_files = true;
option java_package = "io.envoyproxy.envoy.admin.v2alpha";

import "envoy/api/v2/auth/cert.proto";
import "envoy/api/v2/cds.proto";
import "envoy/api/v2/lds.proto";
import "envoy/api/v2/rds.proto";
import "envoy/api/v2/srds.proto";
import "envoy/config/bootstrap/v2/bootstrap.proto";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

// [#protodoc-title: ConfigDump]

// The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
// message to maintain and serve arbitrary configuration information from any component in Envoy.
message ConfigDump {
  // This list is serialized and dumped in its entirety at the
  // :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
  //
  // The following configurations are currently supported and will be dumped in the order given
  // below:
  //
  // * *bootstrap*: :ref:`BootstrapConfigDump <envoy_api_msg_admin.v2alpha.BootstrapConfigDump>`
  // * *clusters*: :ref:`ClustersConfigDump <envoy_api_msg_admin.v2alpha.ClustersConfigDump>`
  // * *listeners*: :ref:`ListenersConfigDump <envoy_api_msg_admin.v2alpha.ListenersConfigDump>`
  // * *routes*:  :ref:`RoutesConfigDump <envoy_api_msg_admin.v2alpha.RoutesConfigDump>`
  repeated google.protobuf.Any configs = 1;
}

// This message describes the bootstrap configuration that Envoy was started with. This includes
// any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
// the static portions of an Envoy configuration by reusing the output as the bootstrap
// configuration for another Envoy.
message BootstrapConfigDump {
  config.bootstrap.v2.Bootstrap bootstrap = 1;

  // The timestamp when the BootstrapConfig was last updated.
  google.protobuf.Timestamp last_updated = 2;
}

// Envoy's listener manager fills this message with all currently known listeners. Listener
// configuration information can be used to recreate an Envoy configuration by populating all
// listeners as static listeners or by returning them in a LDS response.
message ListenersConfigDump {
  // Describes a statically loaded listener.
  message StaticListener {
    // The listener config.
    api.v2.Listener listener = 1;

    // The timestamp when the Listener was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  message DynamicListenerState {
    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
    // that the listener was loaded. In the future, discrete per-listener versions may be supported
    // by the API.
    string version_info = 1;

    // The listener config.
    api.v2.Listener listener = 2;

    // The timestamp when the Listener was last updated.
    // FIXME: reviewer we may eventually want last updated and last _successfully_ updated.
    // Given similarity between last_updated (attempt or success) and
    // last_update should this maybe be last_update_attempt so last_update
    // matches?
    google.protobuf.Timestamp last_updated = 3;
  }

  // Describes a dynamically loaded listener via the LDS API.
  // FIXME rename? because otherwise v2->alpha is super confusing but this seems
  // like the right name :-/
  message DynamicListener {
    // FIXME worth splitting name out for easy reference, duplicate cruft?
    // The name or uniqe id of this listener, pulled from the DynamicListenerState config.
    string name = 1;

    // The listener state for any active listener by this name.
    DynamicListenerState active_state = 2;

    // The listener state for any warming listener by this name.
    DynamicListenerState warming_state = 2;

    // The listener state for any draining listener by this name.
    DynamicListenerState draining_state = 3;

    // FIXME alternately we could just have
    // DynamicListenerState failure_state = 4;
    // string error_details = 5;
    // rather than the sub-message
    //
    // FIXME alternately alternately we could have shared UpdateErrorState with
    // a Message error_state (which would be DynamicListenerState for listeners,
    // DynamicClusterState for clusters, and error details for all.
    // I like shared structures but hate "casting" so I'm scrapping reuse.
    message ListenerUpdateErrorState {
      // What this listener would have looked like if it had succeeded
      // FIXME is it confusing to use last_updated to last_attempted_update?
      DynamicListenerState failed_state = 1;

      // Details about the last update attempt
      string details = 4;
    }

    // Set if the last update failed, cleared after the next successful update.
    ListenerUpdateFailureState error_state = 4;
  }

  // This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
  // last processed LDS discovery response. If there are only static bootstrap listeners, this field
  // will be "".
  string version_info = 1;

  // The statically loaded listener configs.
  repeated StaticListener static_listeners = 2;

  // The dynamically loaded active listeners. These are listeners that are available to service
  // data plane traffic.
  repeated DynamicListener dynamic_listeners = 3;
}

// Envoy's cluster manager fills this message with all currently known clusters. Cluster
// configuration information can be used to recreate an Envoy configuration by populating all
// clusters as static clusters or by returning them in a CDS response.
message ClustersConfigDump {
  // Describes a statically loaded cluster.
  message StaticCluster {
    // The cluster config.
    api.v2.Cluster cluster = 1;

    // The timestamp when the Cluster was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  message DynamicCluster {
    // The name or uniqe id of this cluster, pulled from config.
    string name = 1;

    // The cluster state for any active cluster by this name.
    DynamicClusterState active_state = 2;

    // The cluster state for any warming cluster by this name.
    DynamicClusterState warming_state = 2;

    // The cluster state for any draining cluster by this name.
    DynamicClusterState draining_state = 3;

    message ClusterUpdateErrorState {
      DynamicClusterState failed_state = 1;

      // Details about the last update attempt
      string details = 4;
    }

    // Set if the last update failed, cleared after the next successful update.
    ClusterUpdateFailureState error_state = 4;
  }

  // This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
  // last processed CDS discovery response. If there are only static bootstrap clusters, this field
  // will be "".
  string version_info = 1;

  // The statically loaded cluster configs.
  repeated StaticCluster static_clusters = 2;

  // The dynamically loaded active clusters. These are clusters that are available to service
  // data plane traffic.
  repeated DynamicCluster dynamic_clusters = 3;
}

// Envoy's RDS implementation fills this message with all currently loaded routes, as described by
// their RouteConfiguration objects. Static routes configured in the bootstrap configuration are
// separated from those configured dynamically via RDS. Route configuration information can be used
// to recreate an Envoy configuration by populating all routes as static routes or by returning them
// in RDS responses.
message RoutesConfigDump {
  message StaticRouteConfig {
    // The route config.
    api.v2.RouteConfiguration route_config = 1;

    // The timestamp when the Route was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  message DynamicRouteState {
    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    // the route configuration was loaded.
    string version_info = 1;

    // The route config.
    api.v2.RouteConfiguration route_config = 2;

    // The timestamp when the Route was last updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  message DynamicRoute {
    // The name or uniqe id of this route, pulled from config.
    string name = 1;

    // The route state for any active route by this name.
    DynamicRouetState route_state = 2;

    message RouteUpdateErrorState {
      // What this route would have looked like if it had succeeded
      DynamicRouteState failed_state = 1;

      // Details about the last update attempt
      string details = 4;
    }

    // Set if the last update failed, cleared after the next successful update.
    RouteUpdateFailureState error_state = 4;
  }

  // The statically loaded routes.
  repeated StaticRouteConfig static_routes = 2;

  // The dynamically loaded routes.
  repeated DynamicRoute dynamic_routes = 3;
}

// Envoy's scoped RDS implementation fills this message with all currently loaded route
// configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
// the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
// dynamically obtained scopes via the SRDS API.
message ScopedRoutesConfigDump {
  message InlineScopedRoutes {
    // The name assigned to the scoped route configurations.
    string name = 1;

    // The scoped route configurations.
    repeated api.v2.ScopedRouteConfiguration scoped_routes = 2;

    // The timestamp when the scoped route config set was last updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  message DynamicScopedRouteState {
    // The name assigned to the scoped route configurations.
    string name = 1;

    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    // the scoped routes configuration was loaded.
    string version_info = 2;

    // The scoped route configurations.
    repeated api.v2.ScopedRouteConfiguration scoped_routes = 3;

    // The timestamp when the scoped route config set was last updated.
    google.protobuf.Timestamp last_updated = 4;
  }

  message DynamicScopedRoute {
    // The name or uniqe id of this route, pulled from config.
    string name = 1;

    // The scoped route state for any active route by this name.
    DynamicScopedState scoped_route_state = 2;

    message RouteUpdateErrorState {
      // What this route would have looked like if it had succeeded
      DynamicScopedRouteState failed_state = 1;

      // Details about the last update attempt
      string details = 4;
    }

    // The statically loaded scoped route configs.
    repeated InlineScopedRoutes inline_scoped_routes = 1;

    // The dynamically loaded scoped route configs.
    repeated DynamicScopedRoute dynamic_scoped_routes = 2;
  }

  // FIXME do secrets too.
  // Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS.
  message SecretsConfigDump {
    // DynamicSecret contains secret information fetched via SDS.
    message DynamicSecret {
      // The name assigned to the secret.
      string name = 1;

      // This is the per-resource version information.
      string version_info = 2;

      // The timestamp when the secret was last updated.
      google.protobuf.Timestamp last_updated = 3;

      // The actual secret information.
      // Security sensitive information is redacted (replaced with "[redacted]") for
      // private keys and passwords in TLS certificates.
      api.v2.auth.Secret secret = 4;
    }

    // StaticSecret specifies statically loaded secret in bootstrap.
    message StaticSecret {
      // The name assigned to the secret.
      string name = 1;

      // The timestamp when the secret was last updated.
      google.protobuf.Timestamp last_updated = 2;

      // The actual secret information.
      // Security sensitive information is redacted (replaced with "[redacted]") for
      // private keys and passwords in TLS certificates.
      api.v2.auth.Secret secret = 3;
    }

    // The statically loaded secrets.
    repeated StaticSecret static_secrets = 1;

    // The dynamically loaded active secrets. These are secrets that are available to service
    // clusters or listeners.
    repeated DynamicSecret dynamic_active_secrets = 2;

    // The dynamically loaded warming secrets. These are secrets that are currently undergoing
    // warming in preparation to service clusters or listeners.
    repeated DynamicSecret dynamic_warming_secrets = 3;
  }
