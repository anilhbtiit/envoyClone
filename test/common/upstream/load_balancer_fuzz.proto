syntax = "proto3";

package test.common.upstream;

import "validate/validate.proto";
import "envoy/config/cluster/v3/cluster.proto";
import "google/protobuf/empty.proto";

message UpdateHealthFlags {
  //The boolean corresponds to whether this action updates the failover set or not
  bool failover_host_set = 1;
  uint32 num_healthy_hosts = 2;
  uint32 num_degraded_hosts = 3;
  uint32 num_excluded_hosts = 4;
}

message LbAction {
  oneof action_selector {
    option (validate.required) = true;
    UpdateHealthFlags update_health_flags = 1;
    google.protobuf.Empty prefetch = 2;
    google.protobuf.Empty choose_host = 3;
  }
}

//This message represents what LoadBalancerFuzzBase will interact with, performing setup of host sets and calling into load balancers.
//The logic that this message represents and the base class for load balancing fuzzing will be logic that maps to all types of load balancing
//and can be modularly used at the highest level for each load balancer.
message LoadBalancerTestCase {
  envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 1
      [(validate.rules).message.required = true];
  repeated LbAction actions = 2;
  //Ports of hosts constructed range from 80 - 65455, all on the same Ip Address
  //These caps make sure that the port of the hosts constructed does not overflow
  uint32 num_hosts_in_priority_set = 3 [(validate.rules).uint32.lt = 32727];
  uint32 num_hosts_in_failover_set = 4 [(validate.rules).uint32.lt = 32727];
  //Sequential uint64_t's that will return from random() calls in the random generator.
  //Generating the data in the proto makes it deterministic and also makes it follow a
  //true random distribution. Capped at 50 for space efficiency.
  repeated uint64 bytestring_for_random_calls = 5
      [(validate.rules).repeated = {min_items: 1, max_items: 50}];
}
