syntax = "proto3";

package envoy.service.mutation.v3alpha;

import "envoy/config/core/v3/base.proto";
import "envoy/service/auth/v3/attribute_context.proto";
import "envoy/type/v3/http_status.proto";

import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.service.mutation.v3alpha";
option java_outer_classname = "MutationProto";
option java_multiple_files = true;
option java_generic_services = true;
option (udpa.annotations.file_status).work_in_progress = true;
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: External Mutation Service]

// A service that can mutate HTTP requests and responses.
// The overall mutation protocol works like this:
//
// 1. Envoy sends to the service information about the HTTP request.
// 2. The service sends back a MutationResponse message that directs Envoy
//    to either stop processing, continue without it, or send it the
//    next chunk of the message body.
// 3. If so requested, Envoy sends the server a chunk of the message body.
//    and the server sends back a MutationResponse.
// 4. If so requested, Envoy sends the server the HTTP trailers,
//    and the server sends back a MutationResponse.
// 5. At this point, request processing is done, and we pick up again
//    at step 1 when Envoy receives a response from the upstream server.
// 6. At any point above, if the server closes the gRPC stream cleanly,
//    then Envoy proceeds without consulting the server.
// 7. At any point above, if the server closes the gRPC stream with an error,
//    then Envoy returns a 500 error to the client, unless the filter
//    was configured to ignore errors.
//
// In other words, the process is a request/response conversation, but
// using a gRPC stream to make it easier for the client and server to
// maintain state. The exception is the "SEND_BODY_ASYNC" command,
// which requests that the server keep sending body chunks without waiting
// for a response.

service Mutation {
  // This begins the bidirectional stream that Envoy will use to
  // give the server control over what the filter does. The actual
  // protocol is described by the MutationRequest and MutationResponse
  // messages below.
  rpc Mutate(stream MutationRequest) returns (stream MutationResponse) {
  }
}

// This represents the different types of messages that Envoy can send
// to a mutation server.
message MutationRequest {
  oneof r {
    // Information about the HTTP request, sent after the HTTP headers have been
    // received on the "encoding" path, but before the body is available.
    // This is the same data sent to an "ext_authz" service.
    auth.v3.AttributeContext request = 1;

    // Information about the HTTP response, sent after the HTTP headers have been
    // received on the "decoding" path.
    Response response = 2;

    // A chunk of the HTTP request body. This is only sent if the server
    // requested it.
    Body body = 3;

    // The HTTP trailers, for either the request or response path, depending
    // on where we are in the filter lifecycle. This is only sent if the
    // server requested it.
    config.core.v3.HeaderMap trailers = 4;
  }
}

// The mutation server may respond with zero or more of these responses
// before closing the stream.
// [#next-free-field: 7]
message MutationResponse {
  enum Disposition {
    // The server is done with the request or response -- continue processing
    // and do not consult the server again for this request or response.
    CONTINUE = 0;

    // The server is done with the request and response, and no further
    // filters should be invoked. This is typically used with the
    // "CompleteResponse" field.
    STOP = 1;

    // If this is returned, Envoy will next send a Body message downstream
    // containing either the next chunk of the body available, or an end-of-stream.
    // Once this is returned, it will no longer be possible to modify the
    // message headers.
    SEND_BODY_CHUNK = 2;

    // If this is returned, Envoy will buffer the entire message body in memory
    // subject to the currently-configured body buffer limit, and send a
    // single Body message downstream containing the entire message body.
    // It is still possible for the server to modify the message headers
    // with the next upstream message.
    SEND_ENTIRE_BODY = 3;

    // If this is returned, Envoy will send each chunk of the message body immediately
    // without buffering, and without waiting for a response until the end of stream
    // has been reached. Any additional upstream messages from the service will
    // be ignored.
    SEND_BODY_ASYNC = 4;

    // If this is returned, Envoy will send the HTTP trailers when they are
    // available. Once trailers have been requested, no more bodies
    // will be delivered, so this must be sent after all desired body chunks are
    // desired.
    SEND_TRAILERS = 5;
  }

  // This indicates how to handle the next step in the processing chain,
  // as shown by the enum constants above.
  Disposition disposition = 1 [(validate.rules).enum = {defined_only: true}];

  // Replace the entire HTTP response (whether on the request or on the
  // response path) with the contents of the CompleteResponse message.
  // If a STOP disposition is set, then send this response back immediately
  // to the client with no additional filter processing
  CompleteResponse complete_response = 2;

  // Add or replace HTTP headers. This will be ignored after SEND_BODY_CHUNK
  // or SEND_BODY_ASYNC have been sent. If SEND_TRAILERS was previously sent, then
  // modify the trailers instead.
  repeated config.core.v3.HeaderValueOption set_headers = 3;

  // Remove these HTTP headers. This will be ignored after SEND_BODY_CHUNK
  // or SEND_BODY_ASYNC have been sent. If SEND_TRAILERS was previously sent, then
  // modify the trailers instead.
  repeated string remove_headers = 4;

  // Replace some or all of the last message body received with a new
  // set of bytes. This will be ignored unless the previous message sent
  // by the client is a "*BODY" request.
  BodyMutation body_mutation = 5;

  // Add new metadata to the Envoy context
  google.protobuf.Struct new_metadata = 6;
}

// This message is sent downstream to the server when the HTTP response has been
// received.
// [#next-free-field: 6]
message Response {
  // A unique ID that will match the one sent in the "Request" RPC
  string id = 1;

  // The HTTP status on the response
  int32 status_code = 2;

  // The HTTP headers
  config.core.v3.HeaderMap headers = 3;

  // If the filter was configured to send metadata,
  // then it's set here.
  google.protobuf.Struct metadata = 4;

  // Information about the upstream service's connection
  auth.v3.AttributeContext.Peer destination_info = 5;
}

// This message contains the message body that Envoy sends to the mutation service.
message Body {
  bytes body = 1;

  bool end_of_stream = 2;
}

// This message completely replaces the request or response.
// If a STOP was also returned, then short-circuit the
// rest of the filter processing, and if on the request path,
// return this response directly back to the client.
//
// Otherwise, replace everything
// and let other filters run as they would like.
message CompleteResponse {
  type.v3.HttpStatus status = 1 [(validate.rules).message = {required: true}];

  repeated config.core.v3.HeaderValue headers = 2;

  bytes body = 3;

  repeated config.core.v3.HeaderValue trailers = 4;
}

// Change all or part of the message body by replacing the portion
// of the original body denoted by "offset" and "length" with "body."
message BodyMutation {
  int32 offset = 1;

  int32 length = 2;

  bytes body = 3;
}
