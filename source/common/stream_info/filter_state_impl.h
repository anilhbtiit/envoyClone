#pragma once

#include <map>

#include "envoy/stream_info/filter_state.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace StreamInfo {

class FilterStateImpl : public FilterState {
public:
  // FilterState
  void setData(absl::string_view data_name, std::unique_ptr<Object>&& data) override;
  bool hasDataWithName(absl::string_view) const override;
  const Object* getDataGeneric(absl::string_view data_name) const override;
  void addToListGeneric(absl::string_view data_name, std::unique_ptr<Object>&& data) override;
  const std::vector<std::unique_ptr<Object>>* getList(absl::string_view data_name) const override;
  bool hasListWithName(absl::string_view) const override;

private:
  // The explicit non-type-specific comparator is necessary to allow use of find() method
  // with absl::string_view. See
  // https://stackoverflow.com/questions/20317413/what-are-transparent-comparators.
  std::map<std::string, std::unique_ptr<Object>, std::less<>> data_storage_;
  std::map<std::string, std::vector<std::unique_ptr<Object>>, std::less<>> list_storage_;
};


/**
 * HTTP1.1/HTTP2/GRPC attributes generated by HTTP Connection Manager and
 * its filters are stored under this key in the DynamicInfo associated with
 * a StreamInfo object. The backing object is a List with append-only
 * semantics. Each element in the list has a string key and a
 * string/int/bool value.
 */
static const std::string HCM_ATTRIBUTES = "envoy.hcm.attributes";

/**
 * Attributes generated by various subsystems and filters in the network
 * filter stack are stored under this key in the DynamicInfo associated
 * with a StreamInfo object. The backing object is a List with append-only
 * semantics. Each element in the list has a string key and a
 * string/int/bool value.
 */
static const std::string CONNECTION_ATTRIBUTES = "envoy.connection.attributes";

/**
 * Dynamically generated attributes in StreamInfo.
 */
class DynamicAttribute : public StreamInfo::FilterState::Object {
public:
 DynamicAttribute(absl::string_view key, absl::string_view value) : key_(key), str_val_(value), obj_type_(STR) {}
 DynamicAttribute(absl::string_view key, uint64_t value) : key_(key), uint64_val_(value), obj_type_(UINT64) {}
 DynamicAttribute(absl::string_view key, bool value) : key_(key), bool_val_(value), obj_type_(BOOL) {}

    bool hasString() const { return obj_type_ == STR; }
  bool hasUint64() const { return obj_type_ == UINT64; }
  bool hasBoolean() const { return obj_type_ == BOOL; }

  const std::string& key() const { return key_; }
  const std::string& stringValue() const { return str_val_; }
  uint64_t uint64Value() const { return uint64_val_; }
  bool boolValue() const { return bool_val_; }

private:
  enum objectType {
        UINT64 = 0,
        STR = 1,
        BOOL = 2
  };
  const std::string key_;
  const std::string str_val_;
  const uint64_t uint64_val_;
  const bool bool_val_;
  const objectType obj_type_;
};

} // namespace StreamInfo
} // namespace Envoy
