#include "common/buffer/buffer_impl.h"
#include "common/tcp_proxy/tcp_proxy.h"

#include "extensions/filters/network/proxy_protocol/proxy_protocol.h"

#include "test/mocks/buffer/mocks.h"
#include "test/mocks/network/mocks.h"

using envoy::extensions::filters::network::proxy_protocol::v3::ProxyProtocol_Version;
using testing::AtLeast;
using testing::NiceMock;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace ProxyProtocol {

class ProxyProtocolTest : public testing::Test {
public:
  ProxyProtocolTest() { ENVOY_LOG_MISC(info, "test"); }

  void initialize(ProxyProtocol_Version version) {
    auto config = envoy::extensions::filters::network::proxy_protocol::v3::ProxyProtocol{};
    config.set_version(version);
    filter_ = std::make_unique<Filter>(config);
    filter_->initializeWriteFilterCallbacks(filter_callbacks_);
  }

  void initialize(ProxyProtocol_Version version, absl::string_view src_addr,
                  absl::string_view dst_addr, uint32_t src_port, uint32_t dst_port,
                  Network::Address::IpVersion ip_ver) {
    auto down_addrs =
        std::make_unique<TcpProxy::DownstreamAddrs>(src_addr, dst_addr, src_port, dst_port, ip_ver);
    filter_callbacks_.connection().streamInfo().filterState()->setData(
        down_addrs->key(), std::move(down_addrs), StreamInfo::FilterState::StateType::ReadOnly);
    auto config = envoy::extensions::filters::network::proxy_protocol::v3::ProxyProtocol{};
    config.set_version(version);
    filter_ = std::make_unique<Filter>(config);
    filter_->initializeWriteFilterCallbacks(filter_callbacks_);
  }

  std::unique_ptr<Filter> filter_;
  NiceMock<Network::MockWriteFilterCallbacks> filter_callbacks_;
};

// Test injects V1 PROXY protocol for IP V4 on first data only
TEST_F(ProxyProtocolTest, BasicV1IPV4Send) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V1, "192.168.0.3", "174.2.2.222", 50001,
             80, Network::Address::IpVersion::v4);
  filter_callbacks_.connection_.local_address_ =
      Network::Utility::resolveUrl("tcp://174.2.2.222:80");
  filter_callbacks_.connection_.remote_address_ =
      Network::Utility::resolveUrl("tcp://172.0.0.1:80");

  EXPECT_CALL(filter_callbacks_,
              injectWriteDataToFilterChain(
                  BufferStringEqual("PROXY TCP4 192.168.0.3 174.2.2.222 50001 80\r\n"), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));

  Buffer::InstancePtr msg2(new Buffer::OwnedImpl("more data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg2, false));
}

// Test injects V1 PROXY protocol for IP V6 on first data only
TEST_F(ProxyProtocolTest, BasicV1IPV6Send) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V1, "1::2:3", "a:b:c:d::", 50001, 80,
             Network::Address::IpVersion::v6);
  filter_callbacks_.connection_.local_address_ =
      Network::Utility::resolveUrl("tcp://[a:b:c:d::]:80");
  filter_callbacks_.connection_.remote_address_ =
      Network::Utility::resolveUrl("tcp://[e:b:c:f::]:80");

  EXPECT_CALL(filter_callbacks_,
              injectWriteDataToFilterChain(
                  BufferStringEqual("PROXY TCP6 1::2:3 a:b:c:d:: 50001 80\r\n"), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));

  Buffer::InstancePtr msg2(new Buffer::OwnedImpl("more data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg2, false));
}

// Test assume that the connection is generated by the proxy when no downstream filter state
// available
TEST_F(ProxyProtocolTest, V1IpV4NoFilterStateAssumesLocalConnection) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V1);
  filter_callbacks_.connection_.local_address_ =
      Network::Utility::resolveUrl("tcp://127.0.0.1:50000");
  filter_callbacks_.connection_.remote_address_ =
      Network::Utility::resolveUrl("tcp://172.0.0.1:80");

  EXPECT_CALL(filter_callbacks_,
              injectWriteDataToFilterChain(
                  BufferStringEqual("PROXY TCP4 127.0.0.1 172.0.0.1 50000 80\r\n"), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));
}

// Test assume that the connection is generated by the proxy when no downstream filter state
// available
TEST_F(ProxyProtocolTest, V1IpV6NoFilterStateAssumesLocalConnection) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V1);
  filter_callbacks_.connection_.local_address_ = Network::Utility::resolveUrl("tcp://[::1]:50000");
  filter_callbacks_.connection_.remote_address_ =
      Network::Utility::resolveUrl("tcp://[a:b:c:d::]:80");

  EXPECT_CALL(filter_callbacks_,
              injectWriteDataToFilterChain(
                  BufferStringEqual("PROXY TCP6 ::1 a:b:c:d:: 50000 80\r\n"), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));
}

// Test injects V2 PROXY protocol for IP V4 on first data only
TEST_F(ProxyProtocolTest, BasicV2IPV4Send) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V2, "1.2.3.4", "0.1.1.2", 773, 513,
             Network::Address::IpVersion::v4);
  constexpr uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                     0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,
                                     0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x02, 0x01};
  Buffer::OwnedImpl expected_buff(v2_protocol, 28);

  EXPECT_CALL(filter_callbacks_, injectWriteDataToFilterChain(BufferEqual(&expected_buff), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));

  Buffer::InstancePtr msg2(new Buffer::OwnedImpl("more data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg2, false));
}

// Test injects V2 PROXY protocol for IP V6 on first data only
TEST_F(ProxyProtocolTest, BasicV2IPV6Send) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V2, "1:2:3::4", "1:100:200:3::", 8, 2,
             Network::Address::IpVersion::v6);
  constexpr uint8_t v2_protocol[] = {
      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21,
      0x21, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00,
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02};
  Buffer::OwnedImpl expected_buff(v2_protocol, 52);

  EXPECT_CALL(filter_callbacks_, injectWriteDataToFilterChain(BufferEqual(&expected_buff), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));

  Buffer::InstancePtr msg2(new Buffer::OwnedImpl("more data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg2, false));
}

// Test assume that the connection is generated by the proxy when no downstream filter state
// available
TEST_F(ProxyProtocolTest, V2IpV4NoFilterStateAssumesLocalConnection) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V2);
  filter_callbacks_.connection_.local_address_ =
      Network::Utility::resolveUrl("tcp://127.0.0.1:50000");
  filter_callbacks_.connection_.remote_address_ =
      Network::Utility::resolveUrl("tcp://172.0.0.1:80");

  constexpr uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51,
                                     0x55, 0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00};
  Buffer::OwnedImpl expected_buff(v2_protocol, 16);

  EXPECT_CALL(filter_callbacks_, injectWriteDataToFilterChain(BufferEqual(&expected_buff), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));
}

// Test assume that the connection is generated by the proxy when no downstream filter state
// available
TEST_F(ProxyProtocolTest, V2IpV6NoFilterStateAssumesLocalConnection) {
  initialize(ProxyProtocol_Version::ProxyProtocol_Version_V2);
  filter_callbacks_.connection_.local_address_ = Network::Utility::resolveUrl("tcp://[::1]:50000");
  filter_callbacks_.connection_.remote_address_ =
      Network::Utility::resolveUrl("tcp://[a:b:c:d::]:80");

  constexpr uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51,
                                     0x55, 0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00};
  Buffer::OwnedImpl expected_buff(v2_protocol, 16);

  EXPECT_CALL(filter_callbacks_, injectWriteDataToFilterChain(BufferEqual(&expected_buff), false))
      .Times(1);
  Buffer::InstancePtr msg(new Buffer::OwnedImpl("some data"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*msg, false));
}

} // namespace ProxyProtocol
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
