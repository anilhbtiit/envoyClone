syntax = "proto3";

package envoy.service.mutation.v3alpha;

import "envoy/config/core/v3/base.proto";
import "envoy/service/auth/v3/attribute_context.proto";
import "envoy/type/v3/http_status.proto";

import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.service.mutation.v3alpha";
option java_outer_classname = "MutationProto";
option java_multiple_files = true;
option java_generic_services = true;
option (udpa.annotations.file_status).work_in_progress = true;
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// A service that can mutate HTTP requests and responses.
// The overall mutation protocol works like this:
//
// 1. Envoy sends to the service information about the HTTP request.
// 2. The service sends back a MutationResponse message that directs Envoy
//    to either stop processing, continue without it, or send it the
//    next chunk of the message body.
// 3. If so requested, Envoy sends the server a chunk of the message body.
//    and the server sends back a MutationResponse.
// 4. If so requested, Envoy sends the server the HTTP trailers,
//    and the server sends back a MutationResponse.
// 5. At this point, request processing is done, and we pick up again
//    at step 1 when Envoy receives a response from the upstream server.
// 6. At any point above, if the server closes the gRPC stream cleanly,
//    then Envoy proceeds without consulting the server.
// 7. At any point above, if the server closes the gRPC stream with an error,
//    then Envoy returns a 500 error to the client, unless the filter
//    was configured to ignore errors.
//
// In other words, the process is a request/response conversation, but
// using a gRPC stream to make it easier for the client and server to
// maintain state. The exception is the "SEND_BODY_ASYNC" command,
// which requests that the server keep sending body chunks without waiting
// for a response.

service Mutation {
  // This begins the bidirectional stream that Envoy will use to
  // give the server control over what the filter does. The actual
  // protocol is described by the MutationRequest and MutationResponse
  // messages below.
  rpc Mutate(stream MutationRequest) returns (stream MutationResponse) {
  }
}

// This represents the different types of messages that Envoy can send
// to a mutation server.
message MutationRequest {
  oneof r {
    // Information about the HTTP request, sent after the HTTP headers have been
    // received on the "encoding" path, but before the body is available.
    // This is the same data sent to an "ext_authz" service.
    auth.v3.AttributeContext request = 1;

    // Information about the HTTP response, sent after the HTTP headers have been
    // received on the "decoding" path.
    Response response = 2;

    // A chunk of the HTTP request body. This is only sent if the server
    // requested it.
    Body body = 3;

    // The HTTP trailers, for either the request or response path, depending
    // on where we are in the filter lifecycle. This is only sent if the
    // server requested it.
    config.core.v3.HeaderMap trailers = 4;
  }
}

// The mutation server may respond with zero or more of these responses
// before closing the stream.
// [#next-free-field: 7]
message MutationResponse {
  enum Disposition {
    // The server is done with the request or response -- continue processing
    // and do not consult the server again for this request or response
    CONTINUE = 0;

    // The server is done with the request and response, and no further
    // filters should be invoked. This is typically used with the
    // "CompleteResponse" field.
    STOP = 1;

    // Send the next chunk of the message body (or an empty body to indicate end-of-stream)
    SEND_BODY = 2;

    // Send the next chunk and all subsequent chunks of the message body without
    // waiting for an acknowledgment.
    SEND_BODY_ASYNC = 3;

    // Send the trailers. Note that once trailers have been requested, no more bodies
    // will be delivered, so this must be sent after all desired body chunks are
    // desired.
    SEND_TRAILERS = 4;
  }

  // This indicates how to handle the next step in the processing chain,
  // as shown by the enum constants above.
  Disposition disposition = 1 [(validate.rules).enum = {defined_only: true}];

  // Replace the entire HTTP response (whether on the request or on the
  // response path) with the contents of the CompleteResponse message.
  // If a STOP disposition is set, then send this response back immediately
  // to the client with no additional filter processing
  CompleteResponse complete_response = 2;

  // Add or replace HTTP headers
  repeated config.core.v3.HeaderValueOption set_headers = 3;

  // Remove these HTTP headers
  repeated string remove_headers = 4;

  // Replace some or all of the last message body received with a new
  // set of bytes. If sent after a non-body request, then nothing will
  // happen. If NOT sent after receiving a body chunk, then the body
  // will be unmodified.
  BodyMutation body_mutation = 5;

  // Add new metadata to the Envoy context
  google.protobuf.Struct new_metadata = 6;
}

// [#next-free-field: 6]
message Response {
  // A unique ID that will match the one sent in the "Request" RPC
  string id = 1;

  // The HTTP status on the response
  int32 status_code = 2;

  // The HTTP headers
  config.core.v3.HeaderMap headers = 3;

  // If the filter was configured to send metadata,
  // then it's set here.
  google.protobuf.Struct metadata = 4;

  // Information about the upstream service's connection
  auth.v3.AttributeContext.Peer destination_info = 5;
}

// This message contains the message body that Envoy sends to the mutation service
message Body {
  bytes body = 1;

  bool end_of_stream = 2;
}

// This message completely replaces the request or response.
// If a STOP was also returned, then short-circuit the
// rest of the filter processing, and if on the request path,
// return this response directly back to the client.
//
// Otherwise, replace everything
// and let other filters run as they would like.
message CompleteResponse {
  type.v3.HttpStatus status = 1 [(validate.rules).message = {required: true}];

  repeated config.core.v3.HeaderValue headers = 2;

  bytes body = 3;

  repeated config.core.v3.HeaderValue trailers = 4;
}

// Change all or part of the message body by replacing the portion
// of the original body denoted by offset and length with "body."
// (The intention here is to do what the WASM API does and allow
// the service to prepend, append, replace the middle, or replace
// the whole body, and to use the same parameters that it uses.)
message BodyMutation {
  int32 offset = 1;

  int32 length = 2;

  bytes body = 3;
}
