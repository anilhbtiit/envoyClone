SMTP Decoder: The decoder will parse commands/requests from clients and responses from the server as per RFC 5321 https://www.rfc-editor.org/rfc/rfc5321.
Since SMTP protocol is based on request-response model, in order to calculate metrics, We are maintaining states based on client commands and server responses. See https://www.rfc-editor.org/rfc/rfc5321 section 4.3.2. Command-Reply Sequences.
Below metrics will be provided:
smtp_session_requests
smtp_connection_establishment_errors
smtp_sessions_completed             
smtp_transactions               
smtp_transactions_aborted           
tls_terminated_sessions     
smtp_tls_termination_errors
smtp_auth_errors
smtp_data_transfer_errors        
smtp_errors_4xx                     
smtp_errors_5xx

SMTP Session: Starts with HELO/EHLO command and ends with QUIT command.
MAIL Transaction: Starts with MAIL command and ends with end-of-mail data indicator(<CRLF>.<CRLF>).

Envoy Network Filter Design:
SmtpFilter::onData(Buffer::Instance& data, bool end_stream) - Reads data from downstream connection (client side), calls Decoder's onData() method with upstream flag as false.
SmtpFilter::onWrite(Buffer::Instance& data, bool end_stream) - Reads data from upstream connection (server side), calls Decoder's onData() method with upstream flag as true.
DecoderImpl::onData(Buffer::Instance& data, bool upstream) - Decoder method to parse request/response.

Session/Transaction States in SMTP flow:

C: Open connection                   -> CONNECTION_REQUEST
S: 220 localhost ESMTP Service Ready -> CONNECTION_SUCCESS


C:  EHLO localhost                   -> SESSION_INIT_REQUEST
S:  250-Hello localhost              -> SESSION_IN_PROGRESS
    250-PIPELINING
    250-8BITMIME
    250-ENHANCEDSTATUSCODES
    250-CHUNKING
    250-STARTTLS
    250-AUTH PLAIN
    250 SIZE 1048576
C: STARTTLS                         -> SESSION_IN_PROGRESS
S: 220 Ready to start TLS           -> SESSION_IN_PROGRESS

STARTTLS Handling: When the client sends STARTTLS command, the filter will respond to client with '220 Ready to start TLS' on the upstream's behalf and TLS handshake will take place between the  client and the smtp filter. 
Rest of the messages in the mail transactions will be encrypted between the client and the smtp filter. (See RFC 3207 https://www.rfc-editor.org/rfc/rfc3207) The messages will flow in plain text between the filter and the upstream(email service).

After TLS Handshake, the client again sends EHLO command in an encrypted session which is relayed to upstream in plain text. The server may respond with different set of extensions it supports and excluding STARTTLS. 

C:  EHLO localhost
S:  250-Hello localhost              -> SESSION_IN_PROGRESS
    250-8BITMIME
    250-ENHANCEDSTATUSCODES
    250-CHUNKING
    250-AUTH PLAIN
    250 SIZE 1048576
C:  AUTH PLAIN AHVzZXJuYW1lAHBhc3N3b3Jk
S:  235 2.0.0 Authentication succeeded
C:  MAIL FROM:<edge@freshworks.com> BODY=8BITMIME                   -> TRANSACTION_REQUEST
S:  250 2.0.0 Roger, accepting mail from <edge@freshworks.com>      -> TRANSACTION_IN_PROGRESS
C:  RCPT TO:<api-gateway@freshworks.com>
S:  250 2.0.0 I'll make sure <api-gateway@freshworks.com> gets this
C:  DATA
S:  354 2.0.0 Go ahead. End your data with <CR><LF>.<CR><LF>
C:  Hello World
    ..
    .
    S:  250 2.0.0 OK: queued                                        -> TRANSACTION_COMPLETED
    C:  QUIT                                                        -> SESSION_TERMINATION_REQUEST
S:  221 OK                                                          -> SESSION_TERMINATED






const char* SessionStates[9] = {
      "CONNECTION_REQUEST",       "CONNECTION_SUCCESS",          "SESSION_INIT_REQUEST",
      "SESSION_IN_PROGRESS",      "SESSION_TERMINATION_REQUEST", "SESSION_TERMINATED",
      "UPSTREAM_TLS_NEGOTIATION", "DOWNSTREAM_TLS_NEGOTIATION",  "SESSION_AUTH_REQUEST",
  };

  const char* TransactionStates[8] = {
      "NONE",
      "TRANSACTION_REQUEST",
      "TRANSACTION_IN_PROGRESS",
      "TRANSACTION_ABORT_REQUEST",
      "TRANSACTION_ABORTED",
      "MAIL_DATA_TRANSFER_REQUEST",
      "RCPT_COMMAND",
      "TRANSACTION_COMPLETED",
  };

  std::cout << "current session state: " << SessionStates[static_cast<int>(session_.getState())]
            << "\n";
  std::cout << "current transaction state: "
            << TransactionStates[static_cast<int>(session_.getTransactionState())] << "\n";