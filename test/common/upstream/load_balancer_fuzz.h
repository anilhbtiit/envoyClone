#include "envoy/config/cluster/v3/cluster.pb.h"
#include "common/upstream/load_balancer_impl.h"

#include "test/mocks/common.h"
#include "test/mocks/runtime/mocks.h"
#include "test/mocks/upstream/cluster_info.h"
#include "test/mocks/upstream/host_set.h"
#include "test/mocks/upstream/load_balancer_context.h"
#include "test/mocks/upstream/priority_set.h"

#include "test/common/upstream/load_balancer_fuzz.pb.validate.h"

namespace Envoy {

namespace Random {
class FakeRandomGenerator : public RandomGenerator {
public:
  FakeRandomGenerator() = default;
  ~FakeRandomGenerator() override = default;

  // RandomGenerator
  uint64_t random() override; // returns a part of the generated bytestring
  std::string uuid() override { return ""; }
  uint32_t counter = 0; // Will get modded against byte string length for byte string index
  std::vector<uint64_t> bytestring_; // String of bytes that returns on random() calls
};
} // namespace Random

namespace Upstream {

// This class implements replay logic, and also handles the initial setup of static host sets and the subsequent updates to those sets.
class LoadBalancerFuzzBase {
public:
  LoadBalancerFuzzBase() : stats_(ClusterInfoImpl::generateStats(stats_store_)) {
    
  };

  // Untrusted upstreams don't have the ability to change the host set size, so keep it constant
  // over the fuzz iteration.
  void initializeFixedHostSets(uint32_t num_hosts_in_priority_set,
                               uint32_t num_hosts_in_failover_set);

  virtual void initialize(test::common::upstream::LoadBalancerTestCase input) PURE;
  void initializeAndReplay(test::common::upstream::LoadBalancerTestCase input);
  void updateHealthFlagsForAHostSet(bool failover_host_set, uint32_t num_healthy_hosts,
                                    uint32_t num_degraded_hosts = 0,
                                    uint32_t num_excluded_hosts = 0);
  // These two actions have a lot of logic attached to them such as mocks, so you need to delegate
  // these to specific logic per each specific load balancer. This makes sense, as the load
  // balancing algorithms sometimes use other components which are tightly coupled into the
  // algorithm logically.
  virtual void prefetch() PURE;
  virtual void chooseHost() PURE;
  virtual ~LoadBalancerFuzzBase() = default;
  void replay(test::common::upstream::LoadBalancerTestCase input);
  Stats::IsolatedStoreImpl stats_store_;
  ClusterStats stats_;
  NiceMock<Runtime::MockLoader> runtime_;
  Random::FakeRandomGenerator random_;
  NiceMock<MockPrioritySet> priority_set_;
  MockHostSet& host_set_ = *priority_set_.getMockHostSet(0);
  MockHostSet& failover_host_set_ = *priority_set_.getMockHostSet(1);
  std::shared_ptr<MockClusterInfo> info_{new NiceMock<MockClusterInfo>()};
  // TODO: Move load balancer here?
};

class RandomLoadBalancerFuzzTest : public LoadBalancerFuzzBase {
public:
  RandomLoadBalancerFuzzTest();
  void initialize(test::common::upstream::LoadBalancerTestCase input) override;
  // Has mock logic for random
  void prefetch() override;
  void chooseHost() override;
  ~RandomLoadBalancerFuzzTest() = default;

  std::unique_ptr<RandomLoadBalancer> load_balancer_;
};

// TODO: Since each load balancer has a specific config, this will need to be addressed in their
// specific base classes. We can do this with an extended proto, which also will contain specific
// logic for mocks

} // namespace Upstream
} // namespace Envoy
