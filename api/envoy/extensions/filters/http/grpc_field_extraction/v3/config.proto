syntax = "proto3";

package envoy.extensions.filters.http.grpc_field_extraction.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_field_extraction.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_field_extraction/v3;grpc_field_extractionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC Field Extraction]
// gRPC Field Extraction :ref:`configuration overview
// <config_http_filters_grpc_field_extraction>`.
// [#extension: envoy.filters.http.grpc_field_extraction]

// GrpcFieldExtractionConfig supports extracting the fields from first gRPC
// request message no matter if it is unary or streaming and write the result
// to the destination. Currently only supports dynamic metadata as destination.
//
// When a request reaches the filter, it will check
// 1. if the request is a gRPC request configured for extraction, try doing extraction:
//    a. if successful, write the result into the corresponding dynamic metadata.
//    b. if failed, for example malformed protobuf message as request payload, reject the request
// 2. otherwise, pass through the request.
//
// When the filter is doing extraction, it will **block headers/data propagation** before the extraction
// is done, so that the following filters can rely on the extraction result for processing the current request.
//
// The target field should be singular primitive type or repeated primitive
// type and its value will be extracted in string format. The intermediate type could be repeated.
//
// The result will be written as `field<StringValue>` -> `values<ListValue of StringValue>` into the dynamic metadata<google.protobuf.Struct>.
//
// For example, we have the following request definition for the gRPC method `/pkg.svc/Method`.
//
// message MethodRequest {
//   string foo = 1;
//   Nested nested = 2;
//   ...
// }
//
// message Nested {
//  repeated string bar = 1;
// }
//
// This is the filter config(expressed in JSON format).
// {
//   "proto_descriptor_bin":{...},
//   "extractions_by_method": {
//      "/pkg.svc/Method":{
//         "request_field_extractions":{
//            "foo":{
//            },
//            "nested.bar":{
//            }
//         }
//      }
//   },
//   ...
// }
//
//
// During runtime, the filter receives the following `MethodRequest` message(expressed in JSON format).
// {
//   foo: "val_foo",
//   nested: { "bar": ["val_bar1", "val_bar2"]}
// }
//
// The filter will writes the following dynamic metadata(expressed in JSON format).
//
// envoy.filters.http.grpc_field_extraction: {
//   "foo":[
//      "val_foo"
//   ],
//   "nested.bar":[
//      "val_bar1", "val_bar2"
//   ]
// }

message GrpcFieldExtractionConfig {
  // DescriptorSet is in local data source. It could be either in a local file or embedded in the
  // inline_bytes.
  config.core.v3.DataSource descriptor_set = 1 [(validate.rules).message = {required: true}];

  // Specify the extraction info.
  // The key is the fully qualified gRPC method name.
  // `/$package.$Service/$Method`, like
  // `/endpoints.examples.bookstore.BookStore/GetShelf`
  //
  // The value is the field extractions for individual gRPC method.
  map<string, FieldExtractions> extractions_by_method = 2;
}

// This message can be used to support per route config approach later even
// though the Istio doesn't support that so far.
message FieldExtractions {
  // The field extractions for requests.
  // The key is the field path within the grpc request.
  // For example, we can define `foo.bar.name` if we want to extract
  // Request.foo.bar.name.
  // message Request {
  //   // The namespace in which the Workspace should be created.
  //   Foo foo = 1;
  // }
  //
  // message Foo {
  //   Bar bar = 1;
  // }
  // message Bar {
  //   string name = 1;
  // }
  map<string, RequestFieldExtraction> request_field_extractions = 1;
}

message RequestFieldExtraction {
  // Other than all writing to the default dynamic metadata, potentially we can support
  // 1)more destinations types like headers, 2) per RequestFieldExtraction destination.
}
