diff --git a/base/internal/value.h b/base/internal/value.h
index fb3e845..375dec8 100644
--- a/base/internal/value.h
+++ b/base/internal/value.h
@@ -55,13 +55,9 @@ NativeTypeId GetListValueTypeId(const ListValue& list_value);
 
 NativeTypeId GetMapValueTypeId(const MapValue& map_value);
 
-static_assert(std::is_trivially_copyable_v<absl::Duration>,
-              "absl::Duration must be trivially copyable.");
 static_assert(std::is_trivially_destructible_v<absl::Duration>,
               "absl::Duration must be trivially destructible.");
 
-static_assert(std::is_trivially_copyable_v<absl::Time>,
-              "absl::Time must be trivially copyable.");
 static_assert(std::is_trivially_destructible_v<absl::Time>,
               "absl::Time must be trivially destructible.");
 
@@ -92,6 +88,9 @@ struct InlineValue final {
       int64_t number;
     } enum_value;
   };
+#ifdef _MSC_VER
+  ~InlineValue() = delete;
+#endif
 };
 
 inline constexpr size_t kValueInlineSize = sizeof(InlineValue);
@@ -102,7 +101,11 @@ static_assert(kValueInlineSize <= 32,
 static_assert(kValueInlineAlign <= alignof(std::max_align_t),
               "Alignment of an inline value should not be overaligned.");
 
+#ifdef _MSC_VER
+using AnyValue = AnyData<64, kValueInlineAlign>;
+#else
 using AnyValue = AnyData<kValueInlineSize, kValueInlineAlign>;
+#endif
 
 // Metaprogramming utility for interacting with Value.
 //
diff --git a/base/memory.h b/base/memory.h
index 3552e19..47ca57e 100644
--- a/base/memory.h
+++ b/base/memory.h
@@ -165,9 +165,11 @@ std::enable_if_t<IsDerivedHeapDataV<F>, Handle<T>> HandleFactory<T>::Make(
   static_assert(std::is_base_of_v<T, F>, "F is not derived from T");
 #if defined(__cpp_lib_is_pointer_interconvertible) && \
     __cpp_lib_is_pointer_interconvertible >= 201907L
+#ifndef _MSC_VER
   // Only available in C++20.
   static_assert(std::is_pointer_interconvertible_base_of_v<Data, F>,
                 "F must be pointer interconvertible to Data");
+#endif
 #endif
   if (memory_manager.memory_management() == MemoryManagement::kPooling) {
     void* addr;
diff --git a/base/types/struct_type.h b/base/types/struct_type.h
index 68d2617..95701e1 100644
--- a/base/types/struct_type.h
+++ b/base/types/struct_type.h
@@ -229,8 +229,8 @@ namespace base_internal {
 // heap allocations during interop. So we have an inline variant and heap
 // variant.
 
-ABSL_ATTRIBUTE_WEAK absl::string_view MessageTypeName(uintptr_t msg);
-ABSL_ATTRIBUTE_WEAK size_t MessageTypeFieldCount(uintptr_t msg);
+extern ABSL_ATTRIBUTE_WEAK absl::string_view MessageTypeName(uintptr_t msg);
+extern ABSL_ATTRIBUTE_WEAK size_t MessageTypeFieldCount(uintptr_t msg);
 
 class LegacyStructValueFieldIterator;
 
diff --git a/base/value.h b/base/value.h
index 5d94d5e..d53370c 100644
--- a/base/value.h
+++ b/base/value.h
@@ -336,8 +336,6 @@ CEL_INTERNAL_VALUE_DECL(Value);
 }  // namespace cel
 
 #define CEL_INTERNAL_SIMPLE_VALUE_STANDALONES(value_class)       \
-  static_assert(std::is_trivially_copyable_v<value_class>,       \
-                #value_class " must be trivially copyable");     \
   static_assert(std::is_trivially_destructible_v<value_class>,   \
                 #value_class " must be trivially destructible"); \
                                                                  \
diff --git a/base/values/list_value.h b/base/values/list_value.h
index fb6ed6e..61e1293 100644
--- a/base/values/list_value.h
+++ b/base/values/list_value.h
@@ -146,13 +146,13 @@ class ListValue::Iterator {
 
 namespace base_internal {
 
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> LegacyListValueGet(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> LegacyListValueGet(
     uintptr_t impl, ValueFactory& value_factory, size_t index);
-ABSL_ATTRIBUTE_WEAK size_t LegacyListValueSize(uintptr_t impl);
-ABSL_ATTRIBUTE_WEAK bool LegacyListValueEmpty(uintptr_t impl);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> LegacyListValueAnyOf(
+extern ABSL_ATTRIBUTE_WEAK size_t LegacyListValueSize(uintptr_t impl);
+extern ABSL_ATTRIBUTE_WEAK bool LegacyListValueEmpty(uintptr_t impl);
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> LegacyListValueAnyOf(
     ValueFactory& value_factory, uintptr_t impl, ListValue::AnyOfCallback cb);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> LegacyListValueContains(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> LegacyListValueContains(
     ValueFactory& value_factory, uintptr_t impl, const Handle<Value>& other);
 
 class LegacyListValue final : public ListValue, public InlineData {
diff --git a/base/values/map_value.h b/base/values/map_value.h
index 8e130af..c8d1210 100644
--- a/base/values/map_value.h
+++ b/base/values/map_value.h
@@ -150,14 +150,14 @@ CEL_INTERNAL_VALUE_DECL(MapValue);
 
 namespace base_internal {
 
-ABSL_ATTRIBUTE_WEAK size_t LegacyMapValueSize(uintptr_t impl);
-ABSL_ATTRIBUTE_WEAK bool LegacyMapValueEmpty(uintptr_t impl);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<absl::optional<Handle<Value>>>
+extern ABSL_ATTRIBUTE_WEAK size_t LegacyMapValueSize(uintptr_t impl);
+extern ABSL_ATTRIBUTE_WEAK bool LegacyMapValueEmpty(uintptr_t impl);
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<absl::optional<Handle<Value>>>
 LegacyMapValueGet(uintptr_t impl, ValueFactory& value_factory,
                   const Handle<Value>& key);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> LegacyMapValueHas(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> LegacyMapValueHas(
     uintptr_t impl, const Handle<Value>& key);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<ListValue>> LegacyMapValueListKeys(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<ListValue>> LegacyMapValueListKeys(
     uintptr_t impl, ValueFactory& value_factory);
 
 constexpr absl::string_view kErrNoSuchKey = "Key not found in map";
diff --git a/base/values/struct_value.h b/base/values/struct_value.h
index e7237f6..1bbbfc9 100644
--- a/base/values/struct_value.h
+++ b/base/values/struct_value.h
@@ -217,26 +217,26 @@ namespace base_internal {
 // heap allocations during interop. So we have an inline variant and heap
 // variant.
 
-ABSL_ATTRIBUTE_WEAK void MessageValueHash(uintptr_t msg, uintptr_t type_info,
+extern ABSL_ATTRIBUTE_WEAK void MessageValueHash(uintptr_t msg, uintptr_t type_info,
                                           absl::HashState state);
-ABSL_ATTRIBUTE_WEAK bool MessageValueEquals(uintptr_t lhs_msg,
+extern ABSL_ATTRIBUTE_WEAK bool MessageValueEquals(uintptr_t lhs_msg,
                                             uintptr_t lhs_type_info,
                                             const Value& rhs);
-ABSL_ATTRIBUTE_WEAK size_t MessageValueFieldCount(uintptr_t msg,
+extern ABSL_ATTRIBUTE_WEAK size_t MessageValueFieldCount(uintptr_t msg,
                                                   uintptr_t type_info);
-ABSL_ATTRIBUTE_WEAK std::vector<absl::string_view> MessageValueListFields(
+extern ABSL_ATTRIBUTE_WEAK std::vector<absl::string_view> MessageValueListFields(
     uintptr_t msg, uintptr_t type_info);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> MessageValueHasFieldByNumber(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> MessageValueHasFieldByNumber(
     uintptr_t msg, uintptr_t type_info, int64_t number);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> MessageValueHasFieldByName(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<bool> MessageValueHasFieldByName(
     uintptr_t msg, uintptr_t type_info, absl::string_view name);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> MessageValueGetFieldByNumber(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> MessageValueGetFieldByNumber(
     uintptr_t msg, uintptr_t type_info, ValueFactory& value_factory,
     int64_t number, bool unbox_null_wrapper_types);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<QualifyResult> MessageValueQualify(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<QualifyResult> MessageValueQualify(
     uintptr_t msg, uintptr_t type_info, ValueFactory& value_factory,
     absl::Span<const SelectQualifier> qualifiers, bool presence_test);
-ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> MessageValueGetFieldByName(
+extern ABSL_ATTRIBUTE_WEAK absl::StatusOr<Handle<Value>> MessageValueGetFieldByName(
     uintptr_t msg, uintptr_t type_info, ValueFactory& value_factory,
     absl::string_view name, bool unbox_null_wrapper_types);
 
diff --git a/eval/internal/interop.cc b/eval/internal/interop.cc
index 3acde6c..38db89f 100644
--- a/eval/internal/interop.cc
+++ b/eval/internal/interop.cc
@@ -65,7 +65,7 @@
 #include "google/protobuf/message.h"
 
 namespace google::api::expr::runtime {
-ABSL_ATTRIBUTE_WEAK const LegacyTypeInfoApis& GetGenericProtoTypeInfoInstance();
+extern ABSL_ATTRIBUTE_WEAK const LegacyTypeInfoApis& GetGenericProtoTypeInfoInstance();
 }
 
 namespace cel::interop_internal {
@@ -729,6 +729,7 @@ absl::StatusOr<CelValue> ToLegacyValue(google::protobuf::Arena* arena,
         return CelValue::CreateMessageWrapper(
             MessageWrapperAccess::Make(message, type_info));
       }
+#if ABSL_HAVE_ATTRIBUTE_WEAK
       if (ProtoStructValueToMessageWrapper) {
         auto maybe_message_wrapper = ProtoStructValueToMessageWrapper(*value);
         if (maybe_message_wrapper.has_value()) {
@@ -736,6 +737,7 @@ absl::StatusOr<CelValue> ToLegacyValue(google::protobuf::Arena* arena,
               std::move(maybe_message_wrapper).value());
         }
       }
+#endif
       return absl::UnimplementedError(
           "only legacy struct types and values can be used for interop");
     }
diff --git a/eval/public/cel_value.cc b/eval/public/cel_value.cc
index 6aeff6d..c43864c 100644
--- a/eval/public/cel_value.cc
+++ b/eval/public/cel_value.cc
@@ -107,7 +107,7 @@ struct DebugStringVisitor {
 
 }  // namespace
 
-const absl::string_view kPayloadUrlMissingAttributePath =
+ABSL_CONST_INIT const absl::string_view kPayloadUrlMissingAttributePath =
     cel::runtime_internal::kPayloadUrlMissingAttributePath;
 
 CelValue CelValue::CreateDuration(absl::Duration value) {
diff --git a/internal/strings.cc b/internal/strings.cc
index dc5a118..24457ab 100644
--- a/internal/strings.cc
+++ b/internal/strings.cc
@@ -53,12 +53,12 @@ bool CheckForClosingString(absl::string_view source,
   if (closing_str.empty()) return true;
 
   const char* p = source.data();
-  const char* end = source.end();
+  const char* end = p + source.size();
 
   bool is_closed = false;
   while (p + closing_str.length() <= end) {
     if (*p != '\\') {
-      size_t cur_pos = p - source.begin();
+      size_t cur_pos = p - source.data();
       bool is_closing =
           absl::StartsWith(absl::ClippedSubstr(source, cur_pos), closing_str);
       if (is_closing && p + closing_str.length() < end) {
@@ -132,7 +132,7 @@ bool UnescapeInternal(absl::string_view source, absl::string_view closing_str,
   dest->reserve(source.size());
 
   const char* p = source.data();
-  const char* end = source.end();
+  const char* end = p + source.size();
   const char* last_byte = end - 1;
 
   while (p < end) {
@@ -446,7 +446,9 @@ std::string EscapeInternal(absl::string_view src, bool escape_all_bytes,
   // byte.
   dest.reserve(src.size() * 4);
   bool last_hex_escape = false;  // true if last output char was \xNN.
-  for (const char* p = src.begin(); p < src.end(); ++p) {
+  const char* p = src.data();
+  const char* end = p + src.size();
+  for (; p < end; ++p) {
     unsigned char c = static_cast<unsigned char>(*p);
     bool is_hex_escape = false;
     switch (c) {
@@ -552,7 +554,9 @@ std::string EscapeString(absl::string_view str) {
 std::string EscapeBytes(absl::string_view str, bool escape_all_bytes,
                         char escape_quote_char) {
   std::string escaped_bytes;
-  for (const char* p = str.begin(); p < str.end(); ++p) {
+  const char* p = str.data();
+  const char* end = p + str.size();
+  for (; p < end; ++p) {
     unsigned char c = *p;
     if (escape_all_bytes || !absl::ascii_isprint(c)) {
       escaped_bytes += "\\x";
diff --git a/tools/flatbuffers_backed_impl.cc b/tools/flatbuffers_backed_impl.cc
index 10c0b1c..45ba72f 100644
--- a/tools/flatbuffers_backed_impl.cc
+++ b/tools/flatbuffers_backed_impl.cc
@@ -130,6 +130,7 @@ class ObjectStringIndexedMapImpl : public CelMap {
     return absl::nullopt;
   }
 
+  using CelMap::ListKeys;
   absl::StatusOr<const CelList*> ListKeys() const override { return &keys_; }
 
  private:
