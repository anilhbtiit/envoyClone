#include "envoy/config/cluster/v3/cluster.pb.h"

#include "common/upstream/load_balancer_impl.h"
#include "test/mocks/common.h"
#include "test/mocks/runtime/mocks.h"
#include "test/mocks/upstream/cluster_info.h"
#include "test/mocks/upstream/host_set.h"
#include "test/mocks/upstream/load_balancer_context.h"
#include "test/mocks/upstream/priority_set.h"

namespace Envoy {
namespace Upstream {
namespace {

class LoadBalancerFuzzTestBase {
protected:
  LoadBalancerFuzzTestBase() : stats_(ClusterInfoImpl::generateStats(stats_store_)) {}

  Stats::IsolatedStoreImpl stats_store_;
  ClusterStats stats_;
  NiceMock<Runtime::MockLoader> runtime_;
  NiceMock<Random::MockRandomGenerator> random_;  //TODO: override this Random class to persist state and return a number
  NiceMock<MockPrioritySet> priority_set_;
  MockHostSet& host_set_ = *priority_set_.getMockHostSet(0);
  MockHostSet& failover_host_set_ = *priority_set_.getMockHostSet(1);
  std::shared_ptr<MockClusterInfo> info_{new NiceMock<MockClusterInfo>()};
  envoy::config::cluster::v3::Cluster::CommonLbConfig common_config_;
};

class TestLb : public LoadBalancerBase {
public:
  TestLb(const PrioritySet& priority_set, ClusterStats& stats, Runtime::Loader& runtime,
         Random::RandomGenerator& random,
         const envoy::config::cluster::v3::Cluster::CommonLbConfig& common_config)
      : LoadBalancerBase(priority_set, stats, runtime, random, common_config) {}
  using LoadBalancerBase::chooseHostSet;
  using LoadBalancerBase::isInPanic;
  using LoadBalancerBase::percentageDegradedLoad;
  using LoadBalancerBase::percentageLoad;

  HostConstSharedPtr chooseHostOnce(LoadBalancerContext*) override {
    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
  }
  HostConstSharedPtr peekAnotherHost(LoadBalancerContext*) override {
    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
  }
};

} // namespace
} // namespace Upstream


//repeated uint64t exactly 50 times, if it goes over (persist a counter state variable), use % to get rid of it overflowing
namespace Random {
  class FakeRandomGenerator : public RandomGenerator {
    public:
    FakeRandomGenerator(); //construct it with a long string of bytes that it slowly pulls off of
    ~FakeRandomGenerator() override;

    uint64_t random() override; //returns first few parts of the generated bytestring
    private:
    uint32_t counter = 0; //Will get modded against 50 for byte string index
    std::vector<uint64_t> bytestring_;
  }
}

} // namespace Envoy


//Since each load balancer has a specific config, this will need to be addressed in their specific base classes
//We can do this with an extended proto, which also will contain specific logic for mocks
