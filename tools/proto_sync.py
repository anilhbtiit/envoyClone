#!/usr/bin/env python3

# Diff or copy protoxform artifacts from Bazel cache back to the source tree.

import argparse
import os
import pathlib
import re
import shutil
import string
import subprocess
import sys
import tempfile

from api_proto_plugin import utils

from importlib.util import spec_from_loader, module_from_spec
from importlib.machinery import SourceFileLoader

# api/bazel/external_protos_deps.bzl must have a .bzl suffix for Starlark
# import, so we are forced to this workaround.
_external_proto_deps_spec = spec_from_loader(
    'external_proto_deps',
    SourceFileLoader('external_proto_deps', 'api/bazel/external_proto_deps.bzl'))
external_proto_deps = module_from_spec(_external_proto_deps_spec)
_external_proto_deps_spec.loader.exec_module(external_proto_deps)

# These .proto import direct path prefixes are already handled by
# api_proto_package() as implicit dependencies.
API_BUILD_SYSTEM_IMPORT_PREFIXES = [
    'google/api/annotations.proto',
    'google/protobuf/',
    'google/rpc/status.proto',
    'validate/validate.proto',
]

BUILD_FILE_TEMPLATE = string.Template(
    """# DO NOT EDIT. This file is generated by tools/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

$api_proto_packages
""")

IMPORT_REGEX = re.compile('import "(.*)";')
SERVICE_REGEX = re.compile('service \w+ {')
PACKAGE_REGEX = re.compile('\npackage ([^="]*);')
PREVIOUS_MESSAGE_TYPE_REGEX = re.compile(r'previous_message_type\s+=\s+"([^"]*)";')


class ProtoSyncError(Exception):
  pass


class RequiresReformatError(ProtoSyncError):

  def __init__(self, message):
    super(RequiresReformatError, self).__init__(
        '%s; either run ./ci/do_ci.sh fix_format or ./tools/proto_format.sh fix to reformat.\n' %
        message)


def GetDirectoryFromPackage(package):
  """Get directory path from package name or full qualified message name

  Args:
    package: the full qualified name of package or message.
  """
  return '/'.join(s for s in package.split('.') if s and s[0].islower())


def GetDestinationPath(src):
  """Obtain destination path from a proto file path by reading its package statement.

  Args:
    src: source path
  """
  src_path = pathlib.Path(src)
  contents = src_path.read_text(encoding='utf8')
  matches = re.findall(PACKAGE_REGEX, contents)
  if len(matches) != 1:
    raise RequiresReformatError("Expect {} has only one package declaration but has {}".format(
        src, len(matches)))
  shadow_fixup = "_envoy_internal" if "envoy_internal" in src else ""
  return pathlib.Path(GetDirectoryFromPackage(
      matches[0])).joinpath(src_path.name.split('.')[0] + shadow_fixup + ".proto")


def SyncProtoFile(cmd, src, dst_root):
  """Diff or in-place update a single proto file from protoxform.py Bazel cache artifacts."

  Args:
    cmd: 'check' or 'fix'.
    src: source path.
  """
  # Skip empty files, this indicates this file isn't modified in this version.
  if os.stat(src).st_size == 0:
    return
  dst = dst_root.joinpath(GetDestinationPath(src))
  dst.parent.mkdir(0o755, True, True)
  shutil.copyfile(src, str(dst))


def GetImportDeps(proto_path, shadow):
  """Obtain the Bazel dependencies for the import paths from a .proto file.

  Args:
    proto_path: path to .proto.
    shadow: is this a shadow package?

  Returns:
    A list of Bazel targets reflecting the imports in the .proto at proto_path.
  """
  imports = []
  with open(proto_path, 'r', encoding='utf8') as f:
    for line in f:
      match = re.match(IMPORT_REGEX, line)
      if match:
        import_path = match.group(1)
        # We can ignore imports provided implicitly by api_proto_package().
        if any(import_path.startswith(p) for p in API_BUILD_SYSTEM_IMPORT_PREFIXES):
          continue
        # Special case handling for UDPA annotations.
        if import_path.startswith('udpa/annotations/'):
          imports.append('@com_github_cncf_udpa//udpa/annotations:pkg')
          continue
        # Explicit remapping for external deps, compute paths for envoy/*.
        if import_path in external_proto_deps.EXTERNAL_PROTO_IMPORT_BAZEL_DEP_MAP:
          imports.append(external_proto_deps.EXTERNAL_PROTO_IMPORT_BAZEL_DEP_MAP[import_path])
          continue
        if import_path.startswith('envoy/'):
          # Ignore package internal imports.
          if os.path.dirname(proto_path).endswith(os.path.dirname(import_path)):
            continue
          pkg = 'shadow_pkg' if shadow and 'v3alpha' in import_path else 'pkg'
          imports.append('//%s:%s' % (os.path.dirname(import_path), pkg))
          continue
        raise ProtoSyncError(
            'Unknown import path mapping for %s, please update the mappings in tools/proto_sync.py.\n'
            % import_path)
  return imports


def GetPreviousMessageTypeDeps(proto_path):
  """Obtain the Bazel dependencies for the previous version of messages in a .proto file.

  We need to link in earlier proto descriptors to support Envoy reflection upgrades.

  Args:
    proto_path: path to .proto.

  Returns:
    A list of Bazel targets reflecting the previous message types in the .proto at proto_path.
  """
  contents = pathlib.Path(proto_path).read_text(encoding='utf8')
  matches = re.findall(PREVIOUS_MESSAGE_TYPE_REGEX, contents)
  deps = []
  for m in matches:
    target = '//%s:pkg' % GetDirectoryFromPackage(m)
    deps.append(target)
  return deps


def HasServices(proto_path):
  """Does a .proto file have any service definitions?

  Args:
    proto_path: path to .proto.

  Returns:
    True iff there are service definitions in the .proto at proto_path.
  """
  with open(proto_path, 'r', encoding='utf8') as f:
    for line in f:
      if re.match(SERVICE_REGEX, line):
        return True
  return False


def ApiProtoPackageContents(root, files, shadow):
  """Compute the ApiProtoPackage contents for an api/ proto directory.

  Args:
    root: base path to directory.
    files: a list of files in the directory.
    shadow: is this a shadow package?

  Returns:
    A string containing the api_proto_package target.
  """
  import_deps = set(sum([GetImportDeps(os.path.join(root, f), shadow) for f in files], []))
  history_deps = set(sum([GetPreviousMessageTypeDeps(os.path.join(root, f)) for f in files], []))
  deps = import_deps.union(history_deps)
  has_services = any(HasServices(os.path.join(root, f)) for f in files)
  fields = ['    name = "%s",' % ('shadow_pkg' if shadow else 'pkg')]

  def FormatList(xs):
    if len(xs) == 1:
      return '"%s"' % xs[0]
    else:
      return '\n' + '\n'.join(
          '        "%s",' % f for f in sorted(xs, key=lambda s: s.replace(':', '!'))) + '\n    '

  fields.append('    srcs = [%s],' % FormatList(files))
  if has_services:
    fields.append('    has_services = True,')
  if deps:
    fields.append('    deps = [%s],' % FormatList(list(deps)))
  formatted_fields = '\n' + '\n'.join(fields) + '\n' if fields else ''
  return 'api_proto_package(%s)' % formatted_fields


def SyncBuildFiles(cmd, dst_root):
  """Diff or in-place update api/ BUILD files.

  Args:
    cmd: 'check' or 'fix'.
  """
  for root, dirs, files in os.walk(str(dst_root)):
    shadow_proto_files = [f for f in files if f.endswith('_envoy_internal.proto')]
    canonical_proto_files = [
        f for f in files if f.endswith('.proto') and not f.endswith('_envoy_internal.proto')
    ]
    if not canonical_proto_files:
      continue
    api_proto_packages = [ApiProtoPackageContents(root, canonical_proto_files, False)]
    if shadow_proto_files:
      api_proto_packages.append(ApiProtoPackageContents(root, shadow_proto_files, True))
    build_contents = BUILD_FILE_TEMPLATE.substitute(
        api_proto_packages='\n\n'.join(api_proto_packages))
    build_path = os.path.join(root, 'BUILD')
    with open(build_path, 'w') as f:
      f.write(build_contents)


def GenerateCurrentApiDir(api_dir, dst_dir):
  """Helper function to generate original API repository to be compared with diff.
  This copies the original API repository and deletes file we don't want to compare.

  Args:
    api_dir: the original api directory
    dst_dir: the api directory to be compared in temporary directory
  """
  dst = dst_dir.joinpath("envoy")
  shutil.copytree(str(api_dir.joinpath("envoy")), str(dst))

  for p in dst.glob('**/*.md'):
    p.unlink()
  # envoy.service.auth.v2alpha exist for compatibility while we don't run in protoxform
  # so we ignore it here.
  shutil.rmtree(str(dst.joinpath("service", "auth", "v2alpha")))


if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--mode', choices=['check', 'fix'])
  parser.add_argument('--api_repo', default='envoy_api')
  parser.add_argument('--api_root', default='api')
  parser.add_argument('labels', nargs='*')
  args = parser.parse_args()

  with tempfile.TemporaryDirectory() as tmp:
    dst_dir = pathlib.Path(tmp).joinpath("b")
    for label in args.labels:
      SyncProtoFile(args.mode, utils.BazelBinPathForOutputArtifact(label, '.v2.proto'), dst_dir)
      SyncProtoFile(args.mode,
                    utils.BazelBinPathForOutputArtifact(label, '.v3alpha.envoy_internal.proto'),
                    dst_dir)
      SyncProtoFile(args.mode, utils.BazelBinPathForOutputArtifact(label, '.v3alpha.proto'),
                    dst_dir)
    SyncBuildFiles(args.mode, dst_dir)

    current_api_dir = pathlib.Path(tmp).joinpath("a")
    current_api_dir.mkdir(0o755, True, True)
    api_root = pathlib.Path(args.api_root)
    GenerateCurrentApiDir(api_root, current_api_dir)

    diff = subprocess.run(['diff', '-Npur', "a", "b"], cwd=tmp, stdout=subprocess.PIPE).stdout

    if diff.strip():
      if args.mode == "check":
        print("Please apply following patch to directory '{}'".format(args.api_root),
              file=sys.stderr)
        print(diff.decode(), file=sys.stderr)
        sys.exit(1)
      if args.mode == "fix":
        subprocess.run(['patch', '-p1'], input=diff, cwd=str(api_root.resolve()))
