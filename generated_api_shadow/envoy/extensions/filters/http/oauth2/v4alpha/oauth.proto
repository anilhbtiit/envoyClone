syntax = "proto3";

package envoy.extensions.filters.http.oauth2.v4alpha;

import "envoy/config/core/v4alpha/http_uri.proto";
import "envoy/config/route/v4alpha/route_components.proto";
import "envoy/extensions/transport_sockets/tls/v4alpha/secret.proto";
import "envoy/type/matcher/v4alpha/path.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.oauth2.v4alpha";
option java_outer_classname = "OauthProto";
option java_multiple_files = true;
option (udpa.annotations.file_status).package_version_status = NEXT_MAJOR_VERSION_CANDIDATE;

// [#protodoc-title: OAuth]
// OAuth :ref:`configuration overview <config_http_filters_oauth>`.
// [#extension: envoy.filters.http.oauth2]
//

message OAuth2Credentials {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials";

  // The client_id to be used in the authorize calls. This value will be URL encoded when sent to the OAuth server.
  string client_id = 1 [(validate.rules).string = {min_bytes: 1}];

  // The secret used to retrieve the access token. This value will be URL encoded when sent to the OAuth server.
  transport_sockets.tls.v4alpha.SdsSecretConfig token_secret = 2
      [(validate.rules).message = {required: true}];

  // Configures how the secret token should be created.
  oneof token_formation {
    option (validate.required) = true;

    // If present, the secret token will be a HMAC using the provided secret.
    transport_sockets.tls.v4alpha.SdsSecretConfig hmac_secret = 3;
  }
}

// OAuth config
//
// [#next-free-field: 8]
message OAuth2Config {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.extensions.filters.http.oauth2.v3.OAuth2Config";

  // Endpoint on the authorization server to retrieve the access token from.
  config.core.v4alpha.HttpUri token_endpoint = 1;

  // The hostname to redirect to for authorization. The filter will redirect
  // to https://<redirection_hostname>/oauth/authorize/ when credentials are not presented.
  string redirection_hostname = 2 [(validate.rules).string = {min_bytes: 1}];

  // Credentials used for OAuth.
  OAuth2Credentials credentials = 3 [(validate.rules).message = {required: true}];

  // The callback path the OAuth server should use.
  string callback_path = 4 [(validate.rules).string = {min_bytes: 1}];

  // The path to sign a user out, clearing their credential cookies.
  type.matcher.v4alpha.PathMatcher signout_path = 5 [(validate.rules).message = {required: true}];

  // Forward the OAuth token as a Bearer to upstream web service.
  bool forward_bearer_token = 6;

  // Any request that matches any of the provided matchers will be passed through without OAuth validation.
  repeated config.route.v4alpha.HeaderMatcher pass_through_matcher = 7;
}

// Filter config.
message OAuth2 {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.extensions.filters.http.oauth2.v3.OAuth2";

  // Leave this empty to disable OAuth2 for a specific route, using per filter config.
  OAuth2Config config = 1;
}
