syntax = "proto3";

package envoy.extensions.filters.http.file_system_buffer.v3;

import "envoy/extensions/common/async_files/v3/async_file_manager.proto";

import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.file_system_buffer.v3";
option java_outer_classname = "FileSystemBufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/file_system_buffer/v3;file_system_bufferv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#not-implemented-hide:]
// The behavior of the filter for a stream.
// [#next-free-field: 6]
message BufferBehavior {
  oneof behavior {
    option (validate.required) = true;

    // Don't inject `content-length` header.
    // Output immediately, buffer only if output is slower than input.
    bool stream_when_possible = 1 [(validate.rules).bool = {const: true}];

    // Never buffer, do nothing.
    bool bypass = 2 [(validate.rules).bool = {const: true}];

    // If `content-length` is not present, buffer the entire input,
    // inject `content-length` header, then output.
    // If `content-length` is already present, act like `stream_when_possible`.
    bool inject_content_length_if_necessary = 3 [(validate.rules).bool = {const: true}];

    // Always buffer the entire input, and inject `content-length`,
    // overwriting any provided content-length header.
    bool fully_buffer_and_always_inject_content_length = 4 [(validate.rules).bool = {const: true}];

    // Always buffer the entire input, do not inject `content-length`.
    bool fully_buffer = 5 [(validate.rules).bool = {const: true}];
  }
}

// [#not-implemented-hide:]
// The configuration for one direction of the filter behavior.
message StreamConfig {
  // Whether to bypass / stream / fully buffer / etc.
  // May be unset, in which case the default is `stream_when_possible`.
  BufferBehavior behavior = 1;

  // The amount stored in the memory buffer before buffering to disk.
  google.protobuf.UInt64Value memory_buffer_bytes_limit = 2;

  // The maximum storage (excluding memory) to be buffered in this filter.
  google.protobuf.UInt64Value storage_buffer_bytes_limit = 3;

  // The maximum amount that can be queued for writing to storage, above which the
  // source is requested to pause. If unset, defaults to the same value as
  // `memory_buffer_bytes_limit`.
  //
  // For example, assuming the recipient is not consuming data at all, if
  // `memory_buffer_bytes_limit` was 32*1024, and `storage_buffer_queue_high_watermark_bytes`
  // was 64*1024, and the filesystem is backed up so writes are not occurring promptly,
  // then:
  // * Any request less than 32*1024 will eventually pass through without ever attempting
  //   to write to disk.
  // * Any request with over 32*1024 buffered will start trying to write to disk.
  //   * If it reaches (32+64)*1024 buffered and not yet written to disk, a high
  //     watermark signal is sent to the source.
  // * Any stream whose total size exceeds
  //   `memory_buffer_bytes_limit + storage_buffer_bytes_limit` will provoke an error.
  //   (Note, if the recipient *is* consuming data then it is possible for such an
  //   oversized request to pass through the buffer filter, provided the recipient
  //   isn't consuming data too slowly.)
  //
  // The low watermark signal is sent when the memory buffer is at size
  //  `memory_buffer_bytes_limit + (storage_buffer_bytes_limit / 2)`.
  google.protobuf.UInt64Value storage_buffer_queue_high_watermark_bytes = 4;
}

// [#not-implemented-hide:]
// Configuration for file system buffer filters.
//
// Most fields are wrapped in well-known types so that we can detect the difference between
// unset and explicitly zero.
//
// Route-specific configs override only the fields they explicitly include; unset
// fields inherit from the vhost or listener-level config, or, if never set,
// and not required, use a default value.
message FileSystemBufferFilterConfig {
  // A configuration for an AsyncFileManager.
  //
  // Must be set somewhere, but may be set at the route/vhost level or the listener level,
  // or both with the more specific taking precedence, so cannot be validate-required.
  common.async_files.v3.AsyncFileManagerConfig manager_config = 1;

  // An optional path to which the unlinked files should be written - this may
  // determine which physical storage device will be used.
  //
  // If unspecified, will use the environment variable `TMPDIR`, or, if that's unset,
  // will use `/tmp`.
  google.protobuf.StringValue storage_buffer_path = 2;

  // The configuration for how to buffer (or not) requests.
  StreamConfig request = 3;

  // The configuration for how to buffer (or not) responses.
  StreamConfig response = 4;
}
