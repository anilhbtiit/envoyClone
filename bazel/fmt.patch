# https://github.com/fmtlib/fmt/pull/1650
diff --git a/CMakeLists.txt b/CMakeLists.txt
index b2e2ad7b1..29b9dd585 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -308,6 +308,7 @@ endif ()
 # Control fuzzing independent of the unit tests.
 if (FMT_FUZZ)
   add_subdirectory(test/fuzzing)
+  target_compile_definitions(fmt PUBLIC FMT_FUZZ)
 endif ()
 
 set(gitignore ${PROJECT_SOURCE_DIR}/.gitignore)
diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h
index 788eb8da5..9cb362731 100644
--- a/include/fmt/format-inl.h
+++ b/include/fmt/format-inl.h
@@ -1151,7 +1151,7 @@ int snprintf_float(T value, int precision, float_specs specs,
   for (;;) {
     auto begin = buf.data() + offset;
     auto capacity = buf.capacity() - offset;
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#ifdef FMT_FUZZ
     if (precision > 100000)
       throw std::runtime_error(
           "fuzz mode - avoid large allocation inside snprintf");
diff --git a/include/fmt/format.h b/include/fmt/format.h
index edad681f3..57825f1ae 100644
--- a/include/fmt/format.h
+++ b/include/fmt/format.h
@@ -699,7 +699,7 @@ class basic_memory_buffer : public internal::buffer<T> {
 
 template <typename T, std::size_t SIZE, typename Allocator>
 void basic_memory_buffer<T, SIZE, Allocator>::grow(std::size_t size) {
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#ifdef FMT_FUZZ
   if (size > 1000) throw std::runtime_error("fuzz mode - won't grow that much");
 #endif
   std::size_t old_capacity = this->capacity();
@@ -1136,7 +1136,7 @@ template <typename Char> class float_writer {
             *it++ = static_cast<Char>('0');
           return it;
         }
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#ifdef FMT_FUZZ
         if (num_zeros > 1000)
           throw std::runtime_error("fuzz mode - avoiding excessive cpu use");
 #endif
diff --git a/src/format.cc b/src/format.cc
index 680e67141..e6849b939 100644
--- a/src/format.cc
+++ b/src/format.cc
@@ -13,7 +13,7 @@ namespace internal {
 template <typename T>
 int format_float(char* buf, std::size_t size, const char* format, int precision,
                  T value) {
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#ifdef FMT_FUZZ
   if (precision > 100000)
     throw std::runtime_error(
         "fuzz mode - avoid large allocation inside snprintf");
diff --git a/test/fuzzing/README.md b/test/fuzzing/README.md
index 0499d00cf..8f7a4536e 100644
--- a/test/fuzzing/README.md
+++ b/test/fuzzing/README.md
@@ -7,14 +7,19 @@ in fmt. It is a part of the continuous fuzzing at
 The source code is modified to make the fuzzing possible without locking up on
 resource exhaustion:
 ```cpp
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#ifdef FMT_FUZZ
 if(spec.precision>100000) {
   throw std::runtime_error("fuzz mode - avoiding large precision");
 }
 #endif
-```
-This macro is the defacto standard for making fuzzing practically possible, see
-[the libFuzzer documentation](https://llvm.org/docs/LibFuzzer.html#fuzzer-friendly-build-mode).
+``` 
+This macro `FMT_FUZZ` is enabled on OSS-Fuzz builds and makes fuzzing
+practically possible. It is used in fmt code to prevent resource exhaustion in
+fuzzing mode.  
+The macro `FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION` is the
+defacto standard for making fuzzing practically possible to disable certain
+fuzzing-unfriendly features (for example, randomness), see [the libFuzzer
+documentation](https://llvm.org/docs/LibFuzzer.html#fuzzer-friendly-build-mode).
 
 ## Running the fuzzers locally
 