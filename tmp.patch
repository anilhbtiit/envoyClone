diff --git a/source/common/http/conn_manager_impl.cc b/source/common/http/conn_manager_impl.cc
index 47a28cf8e..f9e13458a 100644
--- a/source/common/http/conn_manager_impl.cc
+++ b/source/common/http/conn_manager_impl.cc
@@ -112,6 +112,7 @@ const ResponseHeaderMap& ConnectionManagerImpl::continueHeader() {
   return *headers;
 }
 
+#include <iostream>
 void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {
   read_callbacks_ = &callbacks;
   stats_.named_.downstream_cx_total_.inc();
@@ -164,11 +165,14 @@ void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCal
                                        start_drain_cb_.reset();
 
                                        // create timer to _begin_ draining
+                                       std::cout << "------------------ Creating the drain-timer ("
+                                                 << drain_delay.count() << "ms)\n";
                                        createStartDrainTimer(drain_delay);
                                      });
 }
 
 ConnectionManagerImpl::~ConnectionManagerImpl() {
+  std::cout << "Tearing down ConnectionManagerImpl\n";
   stats_.named_.downstream_cx_destroy_.inc();
 
   stats_.named_.downstream_cx_active_.dec();
@@ -508,12 +512,15 @@ void ConnectionManagerImpl::doConnectionClose(
 void ConnectionManagerImpl::createStartDrainTimer(std::chrono::milliseconds drain_delay) {
   start_drain_timer_ = read_callbacks_->connection().dispatcher().createTimer([this]() -> void {
     if (drain_state_ != DrainState::NotDraining) {
+      std::cout << "------------------ Ruh, roh, not draining\n";
       return;
     }
     if (!codec_) {
+      std::cout << "------------------ No codec, running doConnectionClose()\n";
       stats_.named_.downstream_cx_drain_close_.inc();
       doConnectionClose(Network::ConnectionCloseType::FlushWrite, absl::nullopt, "");
     } else {
+      std::cout << "------------------ Yes codec, running startDrainSequence()\n";
       startDrainSequence();
       stats_.named_.downstream_cx_drain_close_.inc();
       for (const auto& stream : streams_) {
diff --git a/source/server/drain_manager_impl.cc b/source/server/drain_manager_impl.cc
index dfc4afab0..255f4e933 100644
--- a/source/server/drain_manager_impl.cc
+++ b/source/server/drain_manager_impl.cc
@@ -3,6 +3,7 @@
 #include <chrono>
 #include <cstdint>
 #include <functional>
+#include <iostream>
 #include <memory>
 
 #include "envoy/config/listener/v3/listener.pb.h"
@@ -17,28 +18,46 @@ namespace Server {
 DrainManagerImpl::DrainManagerImpl(Instance& server,
                                    envoy::config::listener::v3::Listener::DrainType drain_type)
     : server_(server), dispatcher_(server.dispatcher()), drain_type_(drain_type),
-      cbs_(server_.dispatcher()) {}
+      cbs_(server_.dispatcher()), children_(server.dispatcher()) {}
 
 DrainManagerImpl::DrainManagerImpl(Instance& server,
                                    envoy::config::listener::v3::Listener::DrainType drain_type,
                                    Event::Dispatcher& dispatcher)
-    : server_(server), dispatcher_(dispatcher), drain_type_(drain_type), cbs_(dispatcher) {}
+    : server_(server), dispatcher_(dispatcher), drain_type_(drain_type), cbs_(dispatcher),
+      children_(dispatcher) {}
 
 DrainManagerSharedPtr
 DrainManagerImpl::createChildManager(Event::Dispatcher& dispatcher,
                                      envoy::config::listener::v3::Listener::DrainType drain_type) {
   auto child = std::make_shared<DrainManagerImpl>(server_, drain_type, dispatcher);
+  auto child_cb = children_.add(
+      dispatcher, [draining = std::weak_ptr(children_draining_),
+                   done_draining = std::weak_ptr(children_completed_draining_), child]() {
+        std::cout << ">>>>>>>>>>>>>> Initiating child drain sequence\n";
+        auto start_draining = draining.lock();
+        if (start_draining) {
+          start_draining->fetch_add(1);
+        }
+        child->startDrainSequence([done_draining] {
+          std::cout << ">>>>>>>>>>>>>> Concluding child drain sequence\n";
+          auto done = done_draining.lock();
+          if (done) {
+            done->fetch_add(1);
+          }
+        });
+      });
+  child->parent_callback_handle_ = child_cb;
 
   // Wire up the child so that when the parent starts draining, the child also sees the state-change
-  child_drain_cbs_.push_back(addOnDrainCloseCb(
-      dispatcher,
-      [child_ = std::weak_ptr<DrainManagerImpl>(child)](std::chrono::milliseconds) mutable {
-        // disregard the specified delay time and kick off the child drain immediately
-        auto child = child_.lock();
-        if (child) {
-          child->startDrainSequence([] {});
-        }
-      }));
+  // child_drain_cbs_.push_back(addOnDrainCloseCb(
+  //     dispatcher,
+  //     [child_ = std::weak_ptr<DrainManagerImpl>(child)](std::chrono::milliseconds) mutable {
+  //       // disregard the specified delay time and kick off the child drain immediately
+  //       auto child = child_.lock();
+  //       if (child) {
+  //         child->startDrainSequence([] {});
+  //       }
+  //     }));
   return child;
 }
 
@@ -87,14 +106,33 @@ DrainManagerImpl::addOnDrainCloseCb(Event::Dispatcher& dispatcher, DrainCloseCb
   return cbs_.add(dispatcher, cb);
 }
 
+void DrainManagerImpl::onDrainComplete() {
+  std::cout << ">>>>>>>>>>>>>> onDrainComplete() called\n";
+  if (children_draining_->load() > children_completed_draining_->load()) {
+    std::cout << ">>>>>>>>>>>>>> onDrainComplete() delayed by 50ms\n";
+    if (drain_tick_timer_) {
+      drain_tick_timer_->disableTimer();
+    }
+    drain_tick_timer_ = dispatcher_.createTimer([this] { onDrainComplete(); });
+    drain_tick_timer_->enableTimer(std::chrono::milliseconds(50));
+  } else {
+    std::cout << ">>>>>>>>>>>>>> Calling user-provided completion cb\n";
+    drain_complete_cb_();
+  }
+}
+
 void DrainManagerImpl::startDrainSequence(std::function<void()> drain_complete_cb) {
   ASSERT(drain_complete_cb);
   ASSERT(!draining_);
   ASSERT(!drain_tick_timer_);
   draining_ = true;
+  drain_complete_cb_ = drain_complete_cb;
+
+  // Signal to child drain-managers to start their drain sequence
+  children_.runCallbacksWith([] { return std::tuple<>(); });
 
   // Schedule callback to run at end of drain time
-  drain_tick_timer_ = dispatcher_.createTimer(drain_complete_cb);
+  drain_tick_timer_ = dispatcher_.createTimer([this] { onDrainComplete(); });
   const std::chrono::seconds drain_delay(server_.options().drainTime());
   drain_tick_timer_->enableTimer(drain_delay);
   drain_deadline_ = dispatcher_.timeSource().monotonicTime() + drain_delay;
diff --git a/source/server/drain_manager_impl.h b/source/server/drain_manager_impl.h
index b72d40dd0..ae887b63a 100644
--- a/source/server/drain_manager_impl.h
+++ b/source/server/drain_manager_impl.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <atomic>
 #include <chrono>
 #include <functional>
 
@@ -45,6 +46,8 @@ public:
   DrainManagerSharedPtr createChildManager(Event::Dispatcher& dispatcher) override;
 
 private:
+  void onDrainComplete();
+
   Instance& server_;
   Event::Dispatcher& dispatcher_;
   const envoy::config::listener::v3::Listener::DrainType drain_type_;
@@ -55,6 +58,19 @@ private:
   mutable Common::ThreadSafeCallbackManager<std::chrono::milliseconds> cbs_;
   std::vector<Common::ThreadSafeCallbackHandlePtr> child_drain_cbs_;
 
+  // Callbacks called by startDrainSequence to cascade/proxy to children
+  Common::ThreadSafeCallbackManager<> children_;
+
+  // Callback handle parent will invoke to initiate drain-sequence. Created and set
+  // by the parent drain-manager.
+  Common::ThreadSafeCallbackHandlePtr parent_callback_handle_;
+
+  std::shared_ptr<std::atomic<uint64_t>> children_draining_{
+      std::make_shared<std::atomic<uint64_t>>(0)};
+  std::shared_ptr<std::atomic<uint64_t>> children_completed_draining_{
+      std::make_shared<std::atomic<uint64_t>>(0)};
+  std::function<void()> drain_complete_cb_;
+
   Event::TimerPtr parent_shutdown_timer_;
 };
 
