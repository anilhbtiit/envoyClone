From e2a1e56a094b32684f85479ae10398783a266f86 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Fri, 24 Jan 2020 15:02:45 -0800
Subject: [PATCH 01/24] Allow to use a different message as "copy" source
 Preparation for #44

---
 src/mutator.cc | 54 +++++++++++++++++++++++++++-----------------------
 src/mutator.h  |  3 ++-
 2 files changed, 31 insertions(+), 26 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index b3e61cf..9931065 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -273,7 +273,7 @@ class MutationSampler {
 class DataSourceSampler {
  public:
   DataSourceSampler(const ConstFieldInstance& match, RandomEngine* random,
-                    Message* message)
+                    const Message& message)
       : match_(match), random_(random), sampler_(random) {
     Sample(message);
   }
@@ -287,21 +287,21 @@ class DataSourceSampler {
   bool IsEmpty() const { return sampler_.IsEmpty(); }
 
  private:
-  void Sample(Message* message) {
-    const Descriptor* descriptor = message->GetDescriptor();
-    const Reflection* reflection = message->GetReflection();
+  void Sample(const Message& message) {
+    const Descriptor* descriptor = message.GetDescriptor();
+    const Reflection* reflection = message.GetReflection();
 
     int field_count = descriptor->field_count();
     for (int i = 0; i < field_count; ++i) {
       const FieldDescriptor* field = descriptor->field(i);
       if (field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {
         if (field->is_repeated()) {
-          const int field_size = reflection->FieldSize(*message, field);
+          const int field_size = reflection->FieldSize(message, field);
           for (int j = 0; j < field_size; ++j) {
-            Sample(reflection->MutableRepeatedMessage(message, field, j));
+            Sample(reflection->GetRepeatedMessage(message, field, j));
           }
-        } else if (reflection->HasField(*message, field)) {
-          Sample(reflection->MutableMessage(message, field));
+        } else if (reflection->HasField(message, field)) {
+          Sample(reflection->GetMessage(message, field));
         }
       }
 
@@ -313,15 +313,15 @@ class DataSourceSampler {
       }
 
       if (field->is_repeated()) {
-        if (int field_size = reflection->FieldSize(*message, field)) {
-          ConstFieldInstance source(message, field,
+        if (int field_size = reflection->FieldSize(message, field)) {
+          ConstFieldInstance source(&message, field,
                                     GetRandomIndex(random_, field_size));
           if (CanCopyAndDifferentField()(source, match_))
             sampler_.Try(field_size, source);
         }
       } else {
-        if (reflection->HasField(*message, field)) {
-          ConstFieldInstance source(message, field);
+        if (reflection->HasField(message, field)) {
+          ConstFieldInstance source(&message, field);
           if (CanCopyAndDifferentField()(source, match_))
             sampler_.Try(1, source);
         }
@@ -340,10 +340,12 @@ class DataSourceSampler {
 class FieldMutator {
  public:
   FieldMutator(size_t size_increase_hint, bool enforce_changes,
-               bool enforce_utf8_strings, Mutator* mutator)
+               bool enforce_utf8_strings, const protobuf::Message& source,
+               Mutator* mutator)
       : size_increase_hint_(size_increase_hint),
         enforce_changes_(enforce_changes),
         enforce_utf8_strings_(enforce_utf8_strings),
+        source_(source),
         mutator_(mutator) {}
 
   void Mutate(int32_t* value) const {
@@ -395,7 +397,7 @@ class FieldMutator {
     assert(*message);
     if (GetRandomBool(mutator_->random(), mutator_->random_to_default_ratio_))
       return;
-    mutator_->MutateImpl(message->get(), size_increase_hint_);
+    mutator_->MutateImpl(source_, message->get(), size_increase_hint_);
   }
 
  private:
@@ -415,6 +417,7 @@ class FieldMutator {
   size_t size_increase_hint_;
   size_t enforce_changes_;
   bool enforce_utf8_strings_;
+  const protobuf::Message& source_;
   Mutator* mutator_;
 };
 
@@ -423,10 +426,10 @@ namespace {
 struct MutateField : public FieldFunction<MutateField> {
   template <class T>
   void ForType(const FieldInstance& field, size_t size_increase_hint,
-               Mutator* mutator) const {
+               const protobuf::Message& source, Mutator* mutator) const {
     T value;
     field.Load(&value);
-    FieldMutator(size_increase_hint, true, field.EnforceUtf8(), mutator)
+    FieldMutator(size_increase_hint, true, field.EnforceUtf8(), source, mutator)
         .Mutate(&value);
     field.Store(value);
   }
@@ -436,12 +439,12 @@ struct CreateField : public FieldFunction<CreateField> {
  public:
   template <class T>
   void ForType(const FieldInstance& field, size_t size_increase_hint,
-               Mutator* mutator) const {
+               const protobuf::Message& source, Mutator* mutator) const {
     T value;
     field.GetDefault(&value);
     FieldMutator field_mutator(size_increase_hint,
                                false /* defaults could be useful */,
-                               field.EnforceUtf8(), mutator);
+                               field.EnforceUtf8(), source, mutator);
     field_mutator.Mutate(&value);
     field.Create(value);
   }
@@ -452,7 +455,7 @@ struct CreateField : public FieldFunction<CreateField> {
 void Mutator::Seed(uint32_t value) { random_.seed(value); }
 
 void Mutator::Mutate(Message* message, size_t size_increase_hint) {
-  MutateImpl(message, size_increase_hint);
+  MutateImpl(*message, message, size_increase_hint);
 
   InitializeAndTrim(message, kMaxInitializeDepth);
   assert(IsInitialized(*message));
@@ -495,25 +498,26 @@ void Mutator::ApplyPostProcessing(Message* message) {
   }
 }
 
-void Mutator::MutateImpl(Message* message, size_t size_increase_hint) {
+void Mutator::MutateImpl(const Message& source, Message* message,
+                         size_t size_increase_hint) {
   for (;;) {
     MutationSampler mutation(keep_initialized_, &random_, message);
     switch (mutation.mutation()) {
       case Mutation::None:
         return;
       case Mutation::Add:
-        CreateField()(mutation.field(), size_increase_hint / 2, this);
+        CreateField()(mutation.field(), size_increase_hint / 2, source, this);
         return;
       case Mutation::Mutate:
-        MutateField()(mutation.field(), size_increase_hint / 2, this);
+        MutateField()(mutation.field(), size_increase_hint / 2, source, this);
         return;
       case Mutation::Delete:
         DeleteField()(mutation.field());
         return;
       case Mutation::Copy: {
-        DataSourceSampler source(mutation.field(), &random_, message);
-        if (source.IsEmpty()) break;
-        CopyField()(source.field(), mutation.field());
+        DataSourceSampler source_sampler(mutation.field(), &random_, source);
+        if (source_sampler.IsEmpty()) break;
+        CopyField()(source_sampler.field(), mutation.field());
         return;
       }
       default:
diff --git a/src/mutator.h b/src/mutator.h
index c5c3af5..087562d 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -95,7 +95,8 @@ class Mutator {
   friend class FieldMutator;
   friend class TestMutator;
   void InitializeAndTrim(protobuf::Message* message, int max_depth);
-  void MutateImpl(protobuf::Message* message, size_t size_increase_hint);
+  void MutateImpl(const protobuf::Message& source, protobuf::Message* message,
+                  size_t size_increase_hint);
   void CrossOverImpl(const protobuf::Message& message1,
                      protobuf::Message* message2);
   std::string MutateUtf8String(const std::string& value,

From 229234341ebb4a40791b5ca5066c8537f90c4ccb Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Fri, 24 Jan 2020 18:35:26 -0800
Subject: [PATCH 02/24] Make post_processors_ private

---
 src/mutator.h | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/mutator.h b/src/mutator.h
index 087562d..13fa199 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -86,9 +86,6 @@ class Mutator {
   virtual std::string MutateString(const std::string& value,
                                    size_t size_increase_hint);
 
-  std::unordered_multimap<const protobuf::Descriptor*, PostProcess>
-      post_processors_;
-
   RandomEngine* random() { return &random_; }
 
  private:
@@ -106,6 +103,8 @@ class Mutator {
   bool keep_initialized_ = true;
   size_t random_to_default_ratio_ = 100;
   RandomEngine random_;
+  std::unordered_multimap<const protobuf::Descriptor*, PostProcess>
+      post_processors_;
 };
 
 }  // namespace protobuf_mutator

From dc0574962b822bdc1a4546d55e02bd149a54609b Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Fri, 24 Jan 2020 19:10:34 -0800
Subject: [PATCH 03/24] Take into account size_increase_hint selecting mutation

---
 src/mutator.cc | 73 ++++++++++++++++++++++++--------------------------
 1 file changed, 35 insertions(+), 38 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index 9931065..9e1583c 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -155,10 +155,14 @@ class CanCopyAndDifferentField
 // Selects random field and mutation from the given proto message.
 class MutationSampler {
  public:
-  MutationSampler(bool keep_initialized, RandomEngine* random, Message* message)
-      : keep_initialized_(keep_initialized), random_(random), sampler_(random) {
+  MutationSampler(bool keep_initialized, bool can_grow, RandomEngine* random,
+                  Message* message)
+      : keep_initialized_(keep_initialized),
+        can_grow_(can_grow),
+        random_(random),
+        sampler_(random) {
     Sample(message);
-    assert(mutation() != Mutation::None ||
+    assert(mutation() != Mutation::None || !can_grow ||
            message->GetDescriptor()->field_count() == 0);
   }
 
@@ -186,59 +190,43 @@ class MutationSampler {
             const FieldDescriptor* add_field =
                 oneof->field(GetRandomIndex(random_, oneof->field_count()));
             if (add_field != current_field) {
-              sampler_.Try(kDefaultMutateWeight,
-                           {{message, add_field}, Mutation::Add});
+              Try({message, add_field}, Mutation::Add);
               break;
             }
             if (oneof->field_count() < 2) break;
           }
           if (current_field) {
-            if (current_field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) {
-              sampler_.Try(kDefaultMutateWeight,
-                           {{message, current_field}, Mutation::Mutate});
-            }
-            sampler_.Try(kDefaultMutateWeight,
-                         {{message, current_field}, Mutation::Delete});
-            sampler_.Try(kDefaultMutateWeight,
-                         {{message, current_field}, Mutation::Copy});
+            if (current_field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE)
+              Try({message, current_field}, Mutation::Mutate);
+            Try({message, current_field}, Mutation::Delete);
+            Try({message, current_field}, Mutation::Copy);
           }
         }
       } else {
         if (field->is_repeated()) {
           int field_size = reflection->FieldSize(*message, field);
-          sampler_.Try(
-              kDefaultMutateWeight,
-              {{message, field, GetRandomIndex(random_, field_size + 1)},
-               Mutation::Add});
+          Try({message, field, GetRandomIndex(random_, field_size + 1)},
+              Mutation::Add);
 
           if (field_size) {
             size_t random_index = GetRandomIndex(random_, field_size);
-            if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) {
-              sampler_.Try(kDefaultMutateWeight,
-                           {{message, field, random_index}, Mutation::Mutate});
-            }
-            sampler_.Try(kDefaultMutateWeight,
-                         {{message, field, random_index}, Mutation::Delete});
-            sampler_.Try(kDefaultMutateWeight,
-                         {{message, field, random_index}, Mutation::Copy});
+            if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE)
+              Try({message, field, random_index}, Mutation::Mutate);
+            Try({message, field, random_index}, Mutation::Delete);
+            Try({message, field, random_index}, Mutation::Copy);
           }
         } else {
           if (reflection->HasField(*message, field) ||
               IsProto3SimpleField(*field)) {
-            if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) {
-              sampler_.Try(kDefaultMutateWeight,
-                           {{message, field}, Mutation::Mutate});
-            }
+            if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE)
+              Try({message, field}, Mutation::Mutate);
             if (!IsProto3SimpleField(*field) &&
                 (!field->is_required() || !keep_initialized_)) {
-              sampler_.Try(kDefaultMutateWeight,
-                           {{message, field}, Mutation::Delete});
+              Try({message, field}, Mutation::Delete);
             }
-            sampler_.Try(kDefaultMutateWeight,
-                         {{message, field}, Mutation::Copy});
+            Try({message, field}, Mutation::Copy);
           } else {
-            sampler_.Try(kDefaultMutateWeight,
-                         {{message, field}, Mutation::Add});
+            Try({message, field}, Mutation::Add);
           }
         }
       }
@@ -255,7 +243,14 @@ class MutationSampler {
     }
   }
 
+  void Try(const FieldInstance& field, Mutation mutation) {
+    assert(mutation != Mutation::None);
+    if (!can_grow_ && mutation != Mutation::Delete) return;
+    sampler_.Try(kDefaultMutateWeight, {field, mutation});
+  }
+
   bool keep_initialized_ = false;
+  bool can_grow_ = false;
 
   RandomEngine* random_;
 
@@ -500,16 +495,18 @@ void Mutator::ApplyPostProcessing(Message* message) {
 
 void Mutator::MutateImpl(const Message& source, Message* message,
                          size_t size_increase_hint) {
+  size_increase_hint /= 2;
   for (;;) {
-    MutationSampler mutation(keep_initialized_, &random_, message);
+    MutationSampler mutation(keep_initialized_, size_increase_hint, &random_,
+                             message);
     switch (mutation.mutation()) {
       case Mutation::None:
         return;
       case Mutation::Add:
-        CreateField()(mutation.field(), size_increase_hint / 2, source, this);
+        CreateField()(mutation.field(), size_increase_hint, source, this);
         return;
       case Mutation::Mutate:
-        MutateField()(mutation.field(), size_increase_hint / 2, source, this);
+        MutateField()(mutation.field(), size_increase_hint, source, this);
         return;
       case Mutation::Delete:
         DeleteField()(mutation.field());

From 16e51674f3eae7ef19fb68172f90c89e93cc0ee2 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sat, 25 Jan 2020 19:33:44 -0800
Subject: [PATCH 04/24] Update README

---
 README.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/README.md b/README.md
index d0c33ea..4e16fb6 100644
--- a/README.md
+++ b/README.md
@@ -62,11 +62,11 @@ To apply one mutation to a protobuf object do the following:
 ```
 class MyProtobufMutator : public protobuf_mutator::Mutator {
  public:
-  MyProtobufMutator(uint32_t seed) : protobuf_mutator::Mutator(seed) {}
   // Optionally redefine the Mutate* methods to perform more sophisticated mutations.
 }
 void Mutate(MyMessage* message) {
-  MyProtobufMutator mutator(my_random_seed);
+  MyProtobufMutator mutator;
+  mutator.Seed(my_random_seed);
   mutator.Mutate(message, 200);
 }
 ```

From 097ac2793a326f441e186fc683c4faa0a7d6ca23 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sat, 25 Jan 2020 19:39:28 -0800
Subject: [PATCH 05/24] Use max_size_hint instead of size_increase_hint

---
 src/libfuzzer/libfuzzer_macro.cc |  6 +++---
 src/mutator.cc                   |  5 +++--
 src/mutator.h                    | 10 ++++------
 src/mutator_test.cc              | 19 +++++++++++++++++++
 4 files changed, 29 insertions(+), 11 deletions(-)

diff --git a/src/libfuzzer/libfuzzer_macro.cc b/src/libfuzzer/libfuzzer_macro.cc
index c37276d..b95a7e8 100644
--- a/src/libfuzzer/libfuzzer_macro.cc
+++ b/src/libfuzzer/libfuzzer_macro.cc
@@ -98,9 +98,9 @@ size_t MutateMessage(unsigned int seed, const InputReader& input,
                      OutputWriter* output, protobuf::Message* message) {
   GetMutator()->Seed(seed);
   input.Read(message);
-  GetMutator()->Mutate(message, output->size() > input.size()
-                                    ? (output->size() - input.size())
-                                    : 0);
+  size_t max_size = message->ByteSizeLong() + output->size();
+  max_size -= std::min(max_size, input.size());
+  GetMutator()->Mutate(message, max_size);
   if (size_t new_size = output->Write(*message)) {
     assert(new_size <= output->size());
     return new_size;
diff --git a/src/mutator.cc b/src/mutator.cc
index 9e1583c..1ec8a61 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -449,8 +449,9 @@ struct CreateField : public FieldFunction<CreateField> {
 
 void Mutator::Seed(uint32_t value) { random_.seed(value); }
 
-void Mutator::Mutate(Message* message, size_t size_increase_hint) {
-  MutateImpl(*message, message, size_increase_hint);
+void Mutator::Mutate(Message* message, size_t max_size_hint) {
+  MutateImpl(*message, message,
+             max_size_hint - std::min(max_size_hint, message->ByteSizeLong()));
 
   InitializeAndTrim(message, kMaxInitializeDepth);
   assert(IsInitialized(*message));
diff --git a/src/mutator.h b/src/mutator.h
index 13fa199..2dfac58 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -52,12 +52,10 @@ class Mutator {
   void Seed(uint32_t value);
 
   // message: message to mutate.
-  // size_increase_hint: approximate number of bytes which can be added to the
-  // message. Method does not guarantee that real result size increase will be
-  // less than the value. It only changes probabilities of mutations which can
-  // cause size increase. Caller could repeat mutation if result was larger than
-  // requested.
-  void Mutate(protobuf::Message* message, size_t size_increase_hint);
+  // max_size_hint: approximate max ByteSize() of resulting message. Method does
+  // not guarantee that real result will be strictly smaller than value. Caller
+  // could repeat mutation if result was larger than expected.
+  void Mutate(protobuf::Message* message, size_t max_size_hint);
 
   void CrossOver(const protobuf::Message& message1,
                  protobuf::Message* message2);
diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index ccaea6c..7e8a1bb 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -721,6 +721,25 @@ TEST_P(MutatorMessagesTest, InsertMessage) {
   EXPECT_TRUE(Mutate(*m1_, *m2_));
 }
 
+class MutatorMessagesSizeTest :  public TestWithParam<size_t> {};
+
+static const size_t kMaxSizes[] = {100, 256, 777, 10101};
+INSTANTIATE_TEST_SUITE_P(Proto, MutatorMessagesSizeTest, ValuesIn(kMaxSizes));
+
+TEST_P(MutatorMessagesSizeTest, MaxSize2) {
+  TestMutator mutator(false);
+  size_t over_sized_count = 0;
+  Msg message;
+  const size_t kMaxSize = GetParam();
+  const int kIterations = 10000;
+  for (int i = 0; i < kIterations; ++i) {
+    mutator.Mutate(&message, kMaxSize);
+    if (message.ByteSizeLong() > kMaxSize) ++over_sized_count;
+    EXPECT_LT(message.ByteSizeLong(), 1.5 * kMaxSize);
+  }
+  EXPECT_LT(over_sized_count, kIterations * .2);
+}
+
 // TODO(vitalybuka): Special tests for oneof.
 
 TEST(MutatorMessagesTest, NeverCopyUnknownEnum) {

From fb320965f0504d8d2c9510047d765e850fb86ed0 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sat, 25 Jan 2020 21:56:22 -0800
Subject: [PATCH 06/24] Use signed size_increase_hint

---
 src/libfuzzer/libfuzzer_mutator.cc |  5 +++--
 src/libfuzzer/libfuzzer_mutator.h  |  2 +-
 src/mutator.cc                     | 23 ++++++++++++-----------
 src/mutator.h                      |  6 +++---
 src/mutator_test.cc                |  2 +-
 5 files changed, 20 insertions(+), 18 deletions(-)

diff --git a/src/libfuzzer/libfuzzer_mutator.cc b/src/libfuzzer/libfuzzer_mutator.cc
index 979cebf..824c521 100644
--- a/src/libfuzzer/libfuzzer_mutator.cc
+++ b/src/libfuzzer/libfuzzer_mutator.cc
@@ -82,13 +82,14 @@ float Mutator::MutateFloat(float value) { return MutateValue(value); }
 double Mutator::MutateDouble(double value) { return MutateValue(value); }
 
 std::string Mutator::MutateString(const std::string& value,
-                                  size_t size_increase_hint) {
+                                  int size_increase_hint) {
   // Randomly return empty strings as LLVMFuzzerMutate does not produce them.
   // Use uint16_t because on Windows, uniform_int_distribution does not support
   // any 8 bit types.
   if (!std::uniform_int_distribution<uint16_t>(0, 20)(*random())) return {};
   std::string result = value;
-  result.resize(value.size() + size_increase_hint);
+  result.resize(value.size() +
+                std::max<int>(-value.size(), size_increase_hint));
   if (result.empty()) result.push_back(0);
   result.resize(LLVMFuzzerMutate(reinterpret_cast<uint8_t*>(&result[0]),
                                  value.size(), result.size()));
diff --git a/src/libfuzzer/libfuzzer_mutator.h b/src/libfuzzer/libfuzzer_mutator.h
index 45ea908..04d6604 100644
--- a/src/libfuzzer/libfuzzer_mutator.h
+++ b/src/libfuzzer/libfuzzer_mutator.h
@@ -37,7 +37,7 @@ class Mutator : public protobuf_mutator::Mutator {
   float MutateFloat(float value) override;
   double MutateDouble(double value) override;
   std::string MutateString(const std::string& value,
-                           size_t size_increase_hint) override;
+                           int size_increase_hint) override;
 };
 
 }  // namespace libfuzzer
diff --git a/src/mutator.cc b/src/mutator.cc
index 1ec8a61..6635141 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -334,7 +334,7 @@ class DataSourceSampler {
 
 class FieldMutator {
  public:
-  FieldMutator(size_t size_increase_hint, bool enforce_changes,
+  FieldMutator(int size_increase_hint, bool enforce_changes,
                bool enforce_utf8_strings, const protobuf::Message& source,
                Mutator* mutator)
       : size_increase_hint_(size_increase_hint),
@@ -409,7 +409,7 @@ class FieldMutator {
     }
   }
 
-  size_t size_increase_hint_;
+  int size_increase_hint_;
   size_t enforce_changes_;
   bool enforce_utf8_strings_;
   const protobuf::Message& source_;
@@ -420,7 +420,7 @@ namespace {
 
 struct MutateField : public FieldFunction<MutateField> {
   template <class T>
-  void ForType(const FieldInstance& field, size_t size_increase_hint,
+  void ForType(const FieldInstance& field, int size_increase_hint,
                const protobuf::Message& source, Mutator* mutator) const {
     T value;
     field.Load(&value);
@@ -433,7 +433,7 @@ struct MutateField : public FieldFunction<MutateField> {
 struct CreateField : public FieldFunction<CreateField> {
  public:
   template <class T>
-  void ForType(const FieldInstance& field, size_t size_increase_hint,
+  void ForType(const FieldInstance& field, int size_increase_hint,
                const protobuf::Message& source, Mutator* mutator) const {
     T value;
     field.GetDefault(&value);
@@ -451,7 +451,8 @@ void Mutator::Seed(uint32_t value) { random_.seed(value); }
 
 void Mutator::Mutate(Message* message, size_t max_size_hint) {
   MutateImpl(*message, message,
-             max_size_hint - std::min(max_size_hint, message->ByteSizeLong()));
+             static_cast<int>(max_size_hint) -
+                 static_cast<int>(message->ByteSizeLong()));
 
   InitializeAndTrim(message, kMaxInitializeDepth);
   assert(IsInitialized(*message));
@@ -495,11 +496,11 @@ void Mutator::ApplyPostProcessing(Message* message) {
 }
 
 void Mutator::MutateImpl(const Message& source, Message* message,
-                         size_t size_increase_hint) {
-  size_increase_hint /= 2;
+                         int size_increase_hint) {
+  if (size_increase_hint > 0) size_increase_hint /= 2;
   for (;;) {
-    MutationSampler mutation(keep_initialized_, size_increase_hint, &random_,
-                             message);
+    MutationSampler mutation(keep_initialized_, size_increase_hint > 0,
+                             &random_, message);
     switch (mutation.mutation()) {
       case Mutation::None:
         return;
@@ -682,7 +683,7 @@ size_t Mutator::MutateEnum(size_t index, size_t item_count) {
 }
 
 std::string Mutator::MutateString(const std::string& value,
-                                  size_t size_increase_hint) {
+                                  int size_increase_hint) {
   std::string result = value;
 
   while (!result.empty() && GetRandomBool(&random_)) {
@@ -707,7 +708,7 @@ std::string Mutator::MutateString(const std::string& value,
 }
 
 std::string Mutator::MutateUtf8String(const std::string& value,
-                                      size_t size_increase_hint) {
+                                      int size_increase_hint) {
   std::string str = MutateString(value, size_increase_hint);
   FixUtf8String(&str, &random_);
   return str;
diff --git a/src/mutator.h b/src/mutator.h
index 2dfac58..6e69892 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -82,7 +82,7 @@ class Mutator {
   virtual bool MutateBool(bool value);
   virtual size_t MutateEnum(size_t index, size_t item_count);
   virtual std::string MutateString(const std::string& value,
-                                   size_t size_increase_hint);
+                                   int size_increase_hint);
 
   RandomEngine* random() { return &random_; }
 
@@ -91,11 +91,11 @@ class Mutator {
   friend class TestMutator;
   void InitializeAndTrim(protobuf::Message* message, int max_depth);
   void MutateImpl(const protobuf::Message& source, protobuf::Message* message,
-                  size_t size_increase_hint);
+                  int size_increase_hint);
   void CrossOverImpl(const protobuf::Message& message1,
                      protobuf::Message* message2);
   std::string MutateUtf8String(const std::string& value,
-                               size_t size_increase_hint);
+                               int size_increase_hint);
   void ApplyPostProcessing(protobuf::Message* message);
   bool IsInitialized(const protobuf::Message& message) const;
   bool keep_initialized_ = true;
diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 7e8a1bb..1369f10 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -258,7 +258,7 @@ class ReducedTestMutator : public TestMutator {
   float MutateFloat(float value) override { return GetRandomValue(); }
   double MutateDouble(double value) override { return GetRandomValue(); }
   std::string MutateString(const std::string& value,
-                           size_t size_increase_hint) override {
+                           int size_increase_hint) override {
     return strings_[std::uniform_int_distribution<>(
         0, strings_.size() - 1)(*random())];
   }

From 0203147314912833e1b2b4ffa325896aed9d2b1a Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sat, 25 Jan 2020 22:03:58 -0800
Subject: [PATCH 07/24] format

---
 src/mutator_test.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 1369f10..1d754cf 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -721,7 +721,7 @@ TEST_P(MutatorMessagesTest, InsertMessage) {
   EXPECT_TRUE(Mutate(*m1_, *m2_));
 }
 
-class MutatorMessagesSizeTest :  public TestWithParam<size_t> {};
+class MutatorMessagesSizeTest : public TestWithParam<size_t> {};
 
 static const size_t kMaxSizes[] = {100, 256, 777, 10101};
 INSTANTIATE_TEST_SUITE_P(Proto, MutatorMessagesSizeTest, ValuesIn(kMaxSizes));

From ac7468b8bc16e8da3397091d9004ea3586727d47 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sat, 25 Jan 2020 22:33:05 -0800
Subject: [PATCH 08/24] Use size_increase_hint selecting copy source

---
 src/mutator.cc      | 37 ++++++++++++++++++++++++++++---------
 src/mutator_test.cc |  6 +++---
 2 files changed, 31 insertions(+), 12 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index 6635141..ed6bbcb 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -124,14 +124,14 @@ class CanCopyAndDifferentField
     : public FieldFunction<CanCopyAndDifferentField, bool> {
  public:
   template <class T>
-  bool ForType(const ConstFieldInstance& src,
-               const ConstFieldInstance& dst) const {
+  bool ForType(const ConstFieldInstance& src, const ConstFieldInstance& dst,
+               int size_increase_hint) const {
     T s;
     src.Load(&s);
     if (!dst.CanStore(s)) return false;
     T d;
     dst.Load(&d);
-    return !IsEqual(s, d);
+    return SizeDiff(s, d) <= size_increase_hint && !IsEqual(s, d);
   }
 
  private:
@@ -150,6 +150,20 @@ class CanCopyAndDifferentField
   bool IsEqual(const T& a, const T& b) const {
     return a == b;
   }
+
+  int64_t SizeDiff(const std::unique_ptr<protobuf::Message>& src,
+                   const std::unique_ptr<protobuf::Message>& dst) const {
+    return src->ByteSizeLong() - dst->ByteSizeLong();
+  }
+
+  int64_t SizeDiff(const std::string& src, const std::string& dst) const {
+    return src.size() - dst.size();
+  }
+
+  template <class T>
+  int64_t SizeDiff(const T&, const T&) const {
+    return 0;
+  }
 };
 
 // Selects random field and mutation from the given proto message.
@@ -268,8 +282,11 @@ class MutationSampler {
 class DataSourceSampler {
  public:
   DataSourceSampler(const ConstFieldInstance& match, RandomEngine* random,
-                    const Message& message)
-      : match_(match), random_(random), sampler_(random) {
+                    int size_increase_hint, const Message& message)
+      : match_(match),
+        random_(random),
+        size_increase_hint_(size_increase_hint),
+        sampler_(random) {
     Sample(message);
   }
 
@@ -311,13 +328,13 @@ class DataSourceSampler {
         if (int field_size = reflection->FieldSize(message, field)) {
           ConstFieldInstance source(&message, field,
                                     GetRandomIndex(random_, field_size));
-          if (CanCopyAndDifferentField()(source, match_))
+          if (CanCopyAndDifferentField()(source, match_, size_increase_hint_))
             sampler_.Try(field_size, source);
         }
       } else {
         if (reflection->HasField(message, field)) {
           ConstFieldInstance source(&message, field);
-          if (CanCopyAndDifferentField()(source, match_))
+          if (CanCopyAndDifferentField()(source, match_, size_increase_hint_))
             sampler_.Try(1, source);
         }
       }
@@ -326,6 +343,7 @@ class DataSourceSampler {
 
   ConstFieldInstance match_;
   RandomEngine* random_;
+  int size_increase_hint_;
 
   WeightedReservoirSampler<ConstFieldInstance, RandomEngine> sampler_;
 };
@@ -499,7 +517,7 @@ void Mutator::MutateImpl(const Message& source, Message* message,
                          int size_increase_hint) {
   if (size_increase_hint > 0) size_increase_hint /= 2;
   for (;;) {
-    MutationSampler mutation(keep_initialized_, size_increase_hint > 0,
+    MutationSampler mutation(keep_initialized_, size_increase_hint > 16,
                              &random_, message);
     switch (mutation.mutation()) {
       case Mutation::None:
@@ -514,7 +532,8 @@ void Mutator::MutateImpl(const Message& source, Message* message,
         DeleteField()(mutation.field());
         return;
       case Mutation::Copy: {
-        DataSourceSampler source_sampler(mutation.field(), &random_, source);
+        DataSourceSampler source_sampler(mutation.field(), &random_,
+                                         size_increase_hint, source);
         if (source_sampler.IsEmpty()) break;
         CopyField()(source_sampler.field(), mutation.field());
         return;
diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 1d754cf..522d7bc 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -726,7 +726,7 @@ class MutatorMessagesSizeTest : public TestWithParam<size_t> {};
 static const size_t kMaxSizes[] = {100, 256, 777, 10101};
 INSTANTIATE_TEST_SUITE_P(Proto, MutatorMessagesSizeTest, ValuesIn(kMaxSizes));
 
-TEST_P(MutatorMessagesSizeTest, MaxSize2) {
+TEST_P(MutatorMessagesSizeTest, MaxSize) {
   TestMutator mutator(false);
   size_t over_sized_count = 0;
   Msg message;
@@ -735,9 +735,9 @@ TEST_P(MutatorMessagesSizeTest, MaxSize2) {
   for (int i = 0; i < kIterations; ++i) {
     mutator.Mutate(&message, kMaxSize);
     if (message.ByteSizeLong() > kMaxSize) ++over_sized_count;
-    EXPECT_LT(message.ByteSizeLong(), 1.5 * kMaxSize);
+    EXPECT_LT(message.ByteSizeLong(), 1.1 * kMaxSize);
   }
-  EXPECT_LT(over_sized_count, kIterations * .2);
+  EXPECT_LT(over_sized_count, kIterations * .1);
 }
 
 // TODO(vitalybuka): Special tests for oneof.

From 650d928acfbc78d0b2d05e5d625088caaaf63b3c Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sun, 26 Jan 2020 01:52:40 -0800
Subject: [PATCH 09/24] Clone implementation

---
 src/mutator.cc | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index ed6bbcb..d1c4ace 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -46,9 +46,7 @@ enum class Mutation {
   Mutate,  // Mutates field contents.
   Delete,  // Deletes field.
   Copy,    // Copy values copied from another field.
-
-  // TODO(vitalybuka):
-  // Clone,  // Adds new field with value copied from another field.
+  Clone,   // Create new field with value copied from another.
 };
 
 // Return random integer from [0, count)
@@ -205,6 +203,7 @@ class MutationSampler {
                 oneof->field(GetRandomIndex(random_, oneof->field_count()));
             if (add_field != current_field) {
               Try({message, add_field}, Mutation::Add);
+              Try({message, add_field}, Mutation::Clone);
               break;
             }
             if (oneof->field_count() < 2) break;
@@ -219,8 +218,9 @@ class MutationSampler {
       } else {
         if (field->is_repeated()) {
           int field_size = reflection->FieldSize(*message, field);
-          Try({message, field, GetRandomIndex(random_, field_size + 1)},
-              Mutation::Add);
+          size_t random_index = GetRandomIndex(random_, field_size + 1);
+          Try({message, field, random_index}, Mutation::Add);
+          Try({message, field, random_index}, Mutation::Clone);
 
           if (field_size) {
             size_t random_index = GetRandomIndex(random_, field_size);
@@ -241,6 +241,7 @@ class MutationSampler {
             Try({message, field}, Mutation::Copy);
           } else {
             Try({message, field}, Mutation::Add);
+            Try({message, field}, Mutation::Clone);
           }
         }
       }
@@ -531,6 +532,14 @@ void Mutator::MutateImpl(const Message& source, Message* message,
       case Mutation::Delete:
         DeleteField()(mutation.field());
         return;
+      case Mutation::Clone: {
+        CreateField()(mutation.field(), size_increase_hint, source, this);
+        DataSourceSampler source_sampler(mutation.field(), &random_,
+                                         size_increase_hint, source);
+        if (source_sampler.IsEmpty()) return;  // CreateField is enough.
+        CopyField()(source_sampler.field(), mutation.field());
+        return;
+      }
       case Mutation::Copy: {
         DataSourceSampler source_sampler(mutation.field(), &random_,
                                          size_increase_hint, source);

From cf2a24ce01544e14fc0ac9a1f908c50a4528e7c9 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sun, 26 Jan 2020 22:17:24 -0800
Subject: [PATCH 10/24] Extract GetMaxSize function

---
 src/libfuzzer/libfuzzer_macro.cc | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/libfuzzer/libfuzzer_macro.cc b/src/libfuzzer/libfuzzer_macro.cc
index b95a7e8..51b718f 100644
--- a/src/libfuzzer/libfuzzer_macro.cc
+++ b/src/libfuzzer/libfuzzer_macro.cc
@@ -94,12 +94,18 @@ Mutator* GetMutator() {
   return &mutator;
 }
 
+size_t GetMaxSize(const InputReader& input, const OutputWriter& output,
+                  const protobuf::Message& message) {
+  size_t max_size = message.ByteSizeLong() + output.size();
+  max_size -= std::min(max_size, input.size());
+  return max_size;
+}
+
 size_t MutateMessage(unsigned int seed, const InputReader& input,
                      OutputWriter* output, protobuf::Message* message) {
   GetMutator()->Seed(seed);
   input.Read(message);
-  size_t max_size = message->ByteSizeLong() + output->size();
-  max_size -= std::min(max_size, input.size());
+  size_t max_size = GetMaxSize(input, *output, *message);
   GetMutator()->Mutate(message, max_size);
   if (size_t new_size = output->Write(*message)) {
     assert(new_size <= output->size());

From 4104df51c2dd1364a01fc687a7a40b4b6ae0d87a Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sun, 26 Jan 2020 22:32:57 -0800
Subject: [PATCH 11/24] Use bitset to controll allowed mutations

---
 src/mutator.cc | 29 ++++++++++++++++++++---------
 1 file changed, 20 insertions(+), 9 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index d1c4ace..66e13ff 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -15,6 +15,7 @@
 #include "src/mutator.h"
 
 #include <algorithm>
+#include <bitset>
 #include <map>
 #include <random>
 #include <string>
@@ -40,15 +41,19 @@ namespace {
 const int kMaxInitializeDepth = 200;
 const uint64_t kDefaultMutateWeight = 1000000;
 
-enum class Mutation {
+enum class Mutation : uint8_t {
   None,
   Add,     // Adds new field with default value.
   Mutate,  // Mutates field contents.
   Delete,  // Deletes field.
   Copy,    // Copy values copied from another field.
   Clone,   // Create new field with value copied from another.
+
+  Last = Clone,
 };
 
+using MutationBitset = std::bitset<static_cast<size_t>(Mutation::Last)>;
+
 // Return random integer from [0, count)
 size_t GetRandomIndex(RandomEngine* random, size_t count) {
   assert(count > 0);
@@ -167,14 +172,15 @@ class CanCopyAndDifferentField
 // Selects random field and mutation from the given proto message.
 class MutationSampler {
  public:
-  MutationSampler(bool keep_initialized, bool can_grow, RandomEngine* random,
-                  Message* message)
+  MutationSampler(bool keep_initialized, MutationBitset allowed_mutations,
+                  RandomEngine* random, Message* message)
       : keep_initialized_(keep_initialized),
-        can_grow_(can_grow),
+        allowed_mutations_(allowed_mutations),
         random_(random),
         sampler_(random) {
     Sample(message);
-    assert(mutation() != Mutation::None || !can_grow ||
+    assert(mutation() != Mutation::None ||
+           !allowed_mutations_[static_cast<size_t>(Mutation::Mutate)] ||
            message->GetDescriptor()->field_count() == 0);
   }
 
@@ -260,12 +266,12 @@ class MutationSampler {
 
   void Try(const FieldInstance& field, Mutation mutation) {
     assert(mutation != Mutation::None);
-    if (!can_grow_ && mutation != Mutation::Delete) return;
+    if (!allowed_mutations_[static_cast<size_t>(mutation)]) return;
     sampler_.Try(kDefaultMutateWeight, {field, mutation});
   }
 
   bool keep_initialized_ = false;
-  bool can_grow_ = false;
+  MutationBitset allowed_mutations_;
 
   RandomEngine* random_;
 
@@ -517,9 +523,14 @@ void Mutator::ApplyPostProcessing(Message* message) {
 void Mutator::MutateImpl(const Message& source, Message* message,
                          int size_increase_hint) {
   if (size_increase_hint > 0) size_increase_hint /= 2;
+  MutationBitset mutations;
+  if (size_increase_hint <= 16) {
+    mutations[static_cast<size_t>(Mutation::Delete)] = true;
+  } else {
+    mutations.set();
+  }
   for (;;) {
-    MutationSampler mutation(keep_initialized_, size_increase_hint > 16,
-                             &random_, message);
+    MutationSampler mutation(keep_initialized_, mutations, &random_, message);
     switch (mutation.mutation()) {
       case Mutation::None:
         return;

From 4c0a0c0a45fcbde32a67fd6d6d847771e7691a40 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sun, 26 Jan 2020 23:17:11 -0800
Subject: [PATCH 12/24] Implement CrossOver using Copy/Clone mutations

---
 src/libfuzzer/libfuzzer_macro.cc |   3 +-
 src/mutator.cc                   | 129 +++++++------------------------
 src/mutator.h                    |  10 +--
 src/mutator_test.cc              | 121 ++++++-----------------------
 4 files changed, 58 insertions(+), 205 deletions(-)

diff --git a/src/libfuzzer/libfuzzer_macro.cc b/src/libfuzzer/libfuzzer_macro.cc
index 51b718f..5ee74f1 100644
--- a/src/libfuzzer/libfuzzer_macro.cc
+++ b/src/libfuzzer/libfuzzer_macro.cc
@@ -121,7 +121,8 @@ size_t CrossOverMessages(unsigned int seed, const InputReader& input1,
   GetMutator()->Seed(seed);
   input1.Read(message1);
   input2.Read(message2);
-  GetMutator()->CrossOver(*message2, message1);
+  size_t max_size = GetMaxSize(input1, *output, *message1);
+  GetMutator()->CrossOver(*message2, message1, max_size);
   if (size_t new_size = output->Write(*message1)) {
     assert(new_size <= output->size());
     return new_size;
diff --git a/src/mutator.cc b/src/mutator.cc
index 66e13ff..dd48e2b 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -417,7 +417,7 @@ class FieldMutator {
     assert(*message);
     if (GetRandomBool(mutator_->random(), mutator_->random_to_default_ratio_))
       return;
-    mutator_->MutateImpl(source_, message->get(), size_increase_hint_);
+    mutator_->MutateImpl(source_, message->get(), false, size_increase_hint_);
   }
 
  private:
@@ -475,7 +475,7 @@ struct CreateField : public FieldFunction<CreateField> {
 void Mutator::Seed(uint32_t value) { random_.seed(value); }
 
 void Mutator::Mutate(Message* message, size_t max_size_hint) {
-  MutateImpl(*message, message,
+  MutateImpl(*message, message, false,
              static_cast<int>(max_size_hint) -
                  static_cast<int>(message->ByteSizeLong()));
 
@@ -520,59 +520,63 @@ void Mutator::ApplyPostProcessing(Message* message) {
   }
 }
 
-void Mutator::MutateImpl(const Message& source, Message* message,
-                         int size_increase_hint) {
+bool Mutator::MutateImpl(const Message& source, Message* message,
+                         bool copy_clone_only, int size_increase_hint) {
   if (size_increase_hint > 0) size_increase_hint /= 2;
   MutationBitset mutations;
-  if (size_increase_hint <= 16) {
+  if (copy_clone_only) {
+    mutations[static_cast<size_t>(Mutation::Copy)] = true;
+    mutations[static_cast<size_t>(Mutation::Clone)] = true;
+  } else if (size_increase_hint <= 16) {
     mutations[static_cast<size_t>(Mutation::Delete)] = true;
   } else {
     mutations.set();
   }
-  for (;;) {
+  while (mutations.any()) {
     MutationSampler mutation(keep_initialized_, mutations, &random_, message);
+    // Don't try same mutation next time.
+    mutations[static_cast<size_t>(mutation.mutation())] = false;
     switch (mutation.mutation()) {
       case Mutation::None:
-        return;
+        return true;
       case Mutation::Add:
         CreateField()(mutation.field(), size_increase_hint, source, this);
-        return;
+        return true;
       case Mutation::Mutate:
         MutateField()(mutation.field(), size_increase_hint, source, this);
-        return;
+        return true;
       case Mutation::Delete:
         DeleteField()(mutation.field());
-        return;
+        return true;
       case Mutation::Clone: {
-        CreateField()(mutation.field(), size_increase_hint, source, this);
+        CreateDefaultField()(mutation.field());
         DataSourceSampler source_sampler(mutation.field(), &random_,
                                          size_increase_hint, source);
-        if (source_sampler.IsEmpty()) return;  // CreateField is enough.
+        if (source_sampler.IsEmpty()) return true;  // CreateField is enough.
         CopyField()(source_sampler.field(), mutation.field());
-        return;
+        return true;
       }
       case Mutation::Copy: {
         DataSourceSampler source_sampler(mutation.field(), &random_,
                                          size_increase_hint, source);
         if (source_sampler.IsEmpty()) break;
         CopyField()(source_sampler.field(), mutation.field());
-        return;
+        return true;
       }
       default:
         assert(false && "unexpected mutation");
-        return;
+        return false;
     }
   }
+  return false;
 }
 
-void Mutator::CrossOver(const protobuf::Message& message1,
-                        protobuf::Message* message2) {
-  // CrossOver can produce result which still equals to inputs. So we backup
-  // message2 to later comparison. message1 is already constant.
-  std::unique_ptr<protobuf::Message> message2_copy(message2->New());
-  message2_copy->CopyFrom(*message2);
-
-  CrossOverImpl(message1, message2);
+void Mutator::CrossOver(const Message& message1, Message* message2,
+                        size_t max_size_hint) {
+  int size_increase_hint = static_cast<int>(max_size_hint) -
+                           static_cast<int>(message2->ByteSizeLong());
+  MutateImpl(message1, message2, true, size_increase_hint) ||
+      MutateImpl(*message2, message2, true, size_increase_hint);
 
   InitializeAndTrim(message2, kMaxInitializeDepth);
   assert(IsInitialized(*message2));
@@ -580,85 +584,6 @@ void Mutator::CrossOver(const protobuf::Message& message1,
   if (!post_processors_.empty()) {
     ApplyPostProcessing(message2);
   }
-
-  // Can't call mutate from crossover because of a bug in libFuzzer.
-  // if (MessageDifferencer::Equals(*message2_copy, *message2) ||
-  //     MessageDifferencer::Equals(message1, *message2)) {
-  //   Mutate(message2, 0);
-  // }
-}
-
-void Mutator::CrossOverImpl(const protobuf::Message& message1,
-                            protobuf::Message* message2) {
-  const Descriptor* descriptor = message2->GetDescriptor();
-  const Reflection* reflection = message2->GetReflection();
-  assert(message1.GetDescriptor() == descriptor);
-  assert(message1.GetReflection() == reflection);
-
-  for (int i = 0; i < descriptor->field_count(); ++i) {
-    const FieldDescriptor* field = descriptor->field(i);
-
-    if (field->is_repeated()) {
-      const int field_size1 = reflection->FieldSize(message1, field);
-      int field_size2 = reflection->FieldSize(*message2, field);
-      for (int j = 0; j < field_size1; ++j) {
-        ConstFieldInstance source(&message1, field, j);
-        FieldInstance destination(message2, field, field_size2++);
-        AppendField()(source, destination);
-      }
-
-      assert(field_size2 == reflection->FieldSize(*message2, field));
-
-      // Shuffle
-      for (int j = 0; j < field_size2; ++j) {
-        if (int k = GetRandomIndex(&random_, field_size2 - j)) {
-          reflection->SwapElements(message2, field, j, j + k);
-        }
-      }
-
-      int keep = GetRandomIndex(&random_, field_size2 + 1);
-
-      if (field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {
-        int remove = field_size2 - keep;
-        // Cross some message to keep with messages to remove.
-        int cross = GetRandomIndex(&random_, std::min(keep, remove) + 1);
-        for (int j = 0; j < cross; ++j) {
-          int k = GetRandomIndex(&random_, keep);
-          int r = keep + GetRandomIndex(&random_, remove);
-          assert(k != r);
-          CrossOverImpl(reflection->GetRepeatedMessage(*message2, field, r),
-                        reflection->MutableRepeatedMessage(message2, field, k));
-        }
-      }
-
-      for (int j = keep; j < field_size2; ++j)
-        reflection->RemoveLast(message2, field);
-      assert(keep == reflection->FieldSize(*message2, field));
-
-    } else if (field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {
-      if (!reflection->HasField(message1, field)) {
-        if (GetRandomBool(&random_))
-          DeleteField()(FieldInstance(message2, field));
-      } else if (!reflection->HasField(*message2, field)) {
-        if (GetRandomBool(&random_)) {
-          ConstFieldInstance source(&message1, field);
-          CopyField()(source, FieldInstance(message2, field));
-        }
-      } else {
-        CrossOverImpl(reflection->GetMessage(message1, field),
-                      reflection->MutableMessage(message2, field));
-      }
-    } else {
-      if (GetRandomBool(&random_)) {
-        if (reflection->HasField(message1, field)) {
-          ConstFieldInstance source(&message1, field);
-          CopyField()(source, FieldInstance(message2, field));
-        } else {
-          DeleteField()(FieldInstance(message2, field));
-        }
-      }
-    }
-  }
 }
 
 void Mutator::InitializeAndTrim(Message* message, int max_depth) {
diff --git a/src/mutator.h b/src/mutator.h
index 6e69892..0bc2f0b 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -57,8 +57,8 @@ class Mutator {
   // could repeat mutation if result was larger than expected.
   void Mutate(protobuf::Message* message, size_t max_size_hint);
 
-  void CrossOver(const protobuf::Message& message1,
-                 protobuf::Message* message2);
+  void CrossOver(const protobuf::Message& message1, protobuf::Message* message2,
+                 size_t max_size_hint);
 
   // Callback to postprocess mutations.
   // Implementation should use seed to initialize random number generators.
@@ -90,10 +90,8 @@ class Mutator {
   friend class FieldMutator;
   friend class TestMutator;
   void InitializeAndTrim(protobuf::Message* message, int max_depth);
-  void MutateImpl(const protobuf::Message& source, protobuf::Message* message,
-                  int size_increase_hint);
-  void CrossOverImpl(const protobuf::Message& message1,
-                     protobuf::Message* message2);
+  bool MutateImpl(const protobuf::Message& source, protobuf::Message* message,
+                  bool copy_clone_only, int size_increase_hint);
   std::string MutateUtf8String(const std::string& value,
                                int size_increase_hint);
   void ApplyPostProcessing(protobuf::Message* message);
diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 522d7bc..ee79ada 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -224,12 +224,6 @@ class TestMutator : public Mutator {
     keep_initialized_ = keep_initialized;
   }
 
-  // Avoids dedup logic for some tests.
-  void NoDeDupCrossOver(const protobuf::Message& message1,
-                        protobuf::Message* message2) {
-    CrossOverImpl(message1, message2);
-  }
-
  private:
   RandomEngine random_;
 };
@@ -329,6 +323,20 @@ bool Mutate(const protobuf::Message& from, const protobuf::Message& to) {
   return false;
 }
 
+bool CrossOver(const protobuf::Message& from, const protobuf::Message& with,
+               const protobuf::Message& to) {
+  EXPECT_FALSE(MessageDifferencer::Equals(from, to));
+  ReducedTestMutator mutator;
+  std::unique_ptr<protobuf::Message> message(from.New());
+  EXPECT_FALSE(MessageDifferencer::Equals(from, to));
+  for (int j = 0; j < 1000000; ++j) {
+    message->CopyFrom(from);
+    mutator.CrossOver(with, message.get(), 1000);
+    if (MessageDifferencer::Equals(*message, to)) return true;
+  }
+  return false;
+}
+
 class MutatorTest : public TestWithParam<TestParams> {
  protected:
   void SetUp() override {
@@ -433,6 +441,16 @@ TEST_P(MutatorFieldTest, ChangeField) {
   EXPECT_TRUE(Mutate(*m2_, *m1_));
 }
 
+TEST_P(MutatorFieldTest, CrossOver) {
+  LoadWithoutLine(m1_.get());
+  LoadMessage(m2_.get());
+
+  EXPECT_FALSE(MessageDifferencer::Equals(*m1_, *m2_));
+  TestMutator mutator(false);
+
+  EXPECT_TRUE(CrossOver(*m1_, *m2_, *m2_));
+}
+
 template <class Msg>
 void MutatorFieldTest::TestCopyField() {
   LoadWithChangedLine(m1_.get(), 7);
@@ -461,43 +479,6 @@ TEST_P(MutatorFieldTest, CopyField) {
 }
 
 class MutatorSingleFieldTest : public MutatorTest {};
-INSTANTIATE_TEST_SUITE_P(Proto2, MutatorSingleFieldTest,
-                         ValuesIn(GetFieldTestParams<Msg>({
-                             kRequiredFields,
-                             kOptionalFields,
-                             kRequiredNestedFields,
-                             kOptionalNestedFields,
-                         })));
-INSTANTIATE_TEST_SUITE_P(Proto3, MutatorSingleFieldTest,
-                         ValuesIn(GetFieldTestParams<Msg3>({
-                             kOptionalFields,
-                             kOptionalNestedFields,
-                         })));
-
-TEST_P(MutatorSingleFieldTest, CrossOver) {
-  LoadWithoutLine(m1_.get());
-  LoadMessage(m2_.get());
-
-  EXPECT_FALSE(MessageDifferencer::Equals(*m1_, *m2_));
-  TestMutator mutator(false);
-
-  int match_m1_ = 0;
-  int match_m2_ = 0;
-  int iterations = 1000;
-  std::unique_ptr<protobuf::Message> message(m1_->New());
-  for (int j = 0; j < iterations; ++j) {
-    message->CopyFrom(*m1_);
-    mutator.NoDeDupCrossOver(*m2_, message.get());
-    if (MessageDifferencer::Equals(*message, *m2_)) ++match_m2_;
-    if (MessageDifferencer::Equals(*message, *m1_)) ++match_m1_;
-  }
-
-  EXPECT_LT(iterations * .4, match_m1_);
-  EXPECT_GE(iterations * .6, match_m1_);
-  EXPECT_LT(iterations * .4, match_m2_);
-  EXPECT_GE(iterations * .6, match_m2_);
-}
-
 template <typename T>
 class MutatorTypedTest : public ::testing::Test {
  public:
@@ -507,58 +488,6 @@ class MutatorTypedTest : public ::testing::Test {
 using MutatorTypedTestTypes = testing::Types<Msg, Msg3>;
 TYPED_TEST_SUITE(MutatorTypedTest, MutatorTypedTestTypes);
 
-TYPED_TEST(MutatorTypedTest, CrossOverRepeated) {
-  typename TestFixture::Message m1;
-  m1.add_repeated_int32(1);
-  m1.add_repeated_int32(2);
-  m1.add_repeated_int32(3);
-
-  typename TestFixture::Message m2;
-  m2.add_repeated_int32(4);
-  m2.add_repeated_int32(5);
-  m2.add_repeated_int32(6);
-
-  int iterations = 10000;
-  std::set<std::set<int>> sets;
-  TestMutator mutator(false);
-  for (int j = 0; j < iterations; ++j) {
-    typename TestFixture::Message message;
-    message.CopyFrom(m1);
-    mutator.NoDeDupCrossOver(m2, &message);
-    sets.insert(
-        {message.repeated_int32().begin(), message.repeated_int32().end()});
-  }
-
-  EXPECT_EQ(1u << 6, sets.size());
-}
-
-TYPED_TEST(MutatorTypedTest, CrossOverRepeatedMessages) {
-  typename TestFixture::Message m1;
-  auto* rm1 = m1.add_repeated_msg();
-  rm1->add_repeated_int32(1);
-  rm1->add_repeated_int32(2);
-
-  typename TestFixture::Message m2;
-  auto* rm2 = m2.add_repeated_msg();
-  rm2->add_repeated_int32(3);
-  rm2->add_repeated_int32(4);
-  rm2->add_repeated_int32(5);
-  rm2->add_repeated_int32(6);
-
-  int iterations = 10000;
-  std::set<std::set<int>> sets;
-  TestMutator mutator(false);
-  for (int j = 0; j < iterations; ++j) {
-    typename TestFixture::Message message;
-    message.CopyFrom(m1);
-    mutator.NoDeDupCrossOver(m2, &message);
-    for (const auto& msg : message.repeated_msg())
-      sets.insert({msg.repeated_int32().begin(), msg.repeated_int32().end()});
-  }
-
-  EXPECT_EQ(1u << 6, sets.size());
-}
-
 TYPED_TEST(MutatorTypedTest, FailedMutations) {
   TestMutator mutator(false);
   size_t crossovers = 0;
@@ -575,7 +504,7 @@ TYPED_TEST(MutatorTypedTest, FailedMutations) {
     }
 
     tmp.CopyFrom(messages[1]);
-    mutator.CrossOver(messages[0], &tmp);
+    mutator.CrossOver(messages[0], &tmp, 1000);
     if (MessageDifferencer::Equals(tmp, messages[1]) ||
         MessageDifferencer::Equals(tmp, messages[0]))
       ++crossovers;

From faa6d8f2e3bf1f359a21f773fc11537d1fe3e6d6 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Sun, 26 Jan 2020 23:24:10 -0800
Subject: [PATCH 13/24] Remove unneded namespaces

---
 src/mutator.cc | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index dd48e2b..b4a79cb 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -144,8 +144,8 @@ class CanCopyAndDifferentField
     return a.index == b.index;
   }
 
-  bool IsEqual(const std::unique_ptr<protobuf::Message>& a,
-               const std::unique_ptr<protobuf::Message>& b) const {
+  bool IsEqual(const std::unique_ptr<Message>& a,
+               const std::unique_ptr<Message>& b) const {
     return MessageDifferencer::Equals(*a, *b);
   }
 
@@ -154,8 +154,8 @@ class CanCopyAndDifferentField
     return a == b;
   }
 
-  int64_t SizeDiff(const std::unique_ptr<protobuf::Message>& src,
-                   const std::unique_ptr<protobuf::Message>& dst) const {
+  int64_t SizeDiff(const std::unique_ptr<Message>& src,
+                   const std::unique_ptr<Message>& dst) const {
     return src->ByteSizeLong() - dst->ByteSizeLong();
   }
 
@@ -360,7 +360,7 @@ class DataSourceSampler {
 class FieldMutator {
  public:
   FieldMutator(int size_increase_hint, bool enforce_changes,
-               bool enforce_utf8_strings, const protobuf::Message& source,
+               bool enforce_utf8_strings, const Message& source,
                Mutator* mutator)
       : size_increase_hint_(size_increase_hint),
         enforce_changes_(enforce_changes),
@@ -437,7 +437,7 @@ class FieldMutator {
   int size_increase_hint_;
   size_t enforce_changes_;
   bool enforce_utf8_strings_;
-  const protobuf::Message& source_;
+  const Message& source_;
   Mutator* mutator_;
 };
 
@@ -446,7 +446,7 @@ namespace {
 struct MutateField : public FieldFunction<MutateField> {
   template <class T>
   void ForType(const FieldInstance& field, int size_increase_hint,
-               const protobuf::Message& source, Mutator* mutator) const {
+               const Message& source, Mutator* mutator) const {
     T value;
     field.Load(&value);
     FieldMutator(size_increase_hint, true, field.EnforceUtf8(), source, mutator)
@@ -459,7 +459,7 @@ struct CreateField : public FieldFunction<CreateField> {
  public:
   template <class T>
   void ForType(const FieldInstance& field, int size_increase_hint,
-               const protobuf::Message& source, Mutator* mutator) const {
+               const Message& source, Mutator* mutator) const {
     T value;
     field.GetDefault(&value);
     FieldMutator field_mutator(size_increase_hint,
@@ -487,7 +487,7 @@ void Mutator::Mutate(Message* message, size_t max_size_hint) {
   }
 }
 
-void Mutator::RegisterPostProcessor(const protobuf::Descriptor* desc,
+void Mutator::RegisterPostProcessor(const Descriptor* desc,
                                     PostProcess callback) {
   post_processors_.emplace(desc, callback);
 }

From c152d728c950c92206807729fab03a5ef8a4a7fd Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Mon, 27 Jan 2020 17:33:14 -0800
Subject: [PATCH 14/24] Add google.protobuf.Any into test messages

---
 examples/libfuzzer/libfuzzer_example.proto | 3 +++
 src/mutator_test_proto2.proto              | 4 ++++
 src/mutator_test_proto3.proto              | 4 ++++
 3 files changed, 11 insertions(+)

diff --git a/examples/libfuzzer/libfuzzer_example.proto b/examples/libfuzzer/libfuzzer_example.proto
index 71e5fc9..cb25c9d 100644
--- a/examples/libfuzzer/libfuzzer_example.proto
+++ b/examples/libfuzzer/libfuzzer_example.proto
@@ -1,8 +1,11 @@
 syntax = "proto2";
 package libfuzzer_example;
 
+import "google/protobuf/any.proto";
+
 message Msg {
   optional float optional_float = 1;
   optional uint64 optional_uint64 = 2;
   optional string optional_string = 3;
+  optional google.protobuf.Any any = 4;
 }
diff --git a/src/mutator_test_proto2.proto b/src/mutator_test_proto2.proto
index 161ca34..eb9e3c2 100644
--- a/src/mutator_test_proto2.proto
+++ b/src/mutator_test_proto2.proto
@@ -1,6 +1,8 @@
 syntax = "proto2";
 package protobuf_mutator;
 
+import "google/protobuf/any.proto";
+
 message Msg {
   enum Enum {
     ENUM_0 = 0;
@@ -124,6 +126,8 @@ message Msg {
     map<string, int32> map1 = 1;
     map<int32, Msg> map2 = 2;
   }
+
+  optional google.protobuf.Any any = 90;
 }
 
 
diff --git a/src/mutator_test_proto3.proto b/src/mutator_test_proto3.proto
index b3f19f5..f4bd3ed 100644
--- a/src/mutator_test_proto3.proto
+++ b/src/mutator_test_proto3.proto
@@ -1,6 +1,8 @@
 syntax = "proto3";
 package protobuf_mutator;
 
+import "google/protobuf/any.proto";
+
 message Msg3 {
   enum Enum {
     ENUM_0 = 0;
@@ -100,4 +102,6 @@ message Msg3 {
     map<string, int32> map1 = 1;
     map<int32, Msg3> map2 = 2;
   }
+
+  google.protobuf.Any any = 90;
 }

From 445633b77da6afbce6332d6d259e169d45c541aa Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Mon, 27 Jan 2020 18:14:36 -0800
Subject: [PATCH 15/24] Make test output more verbose

---
 src/mutator_test.cc | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index ee79ada..dd18b6c 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -276,7 +276,8 @@ std::vector<std::string> Split(const std::string& str) {
   return result;
 }
 
-using TestParams = std::tuple<const protobuf::Message*, const char*, size_t>;
+using TestParams =
+    std::tuple<const protobuf::Message*, const char*, size_t, std::string>;
 
 template <class T>
 std::vector<TestParams> GetFieldTestParams(
@@ -286,7 +287,8 @@ std::vector<TestParams> GetFieldTestParams(
     auto lines = Split(t);
     for (size_t i = 0; i != lines.size(); ++i) {
       if (lines[i].find(':') != std::string::npos)
-        results.push_back(std::make_tuple(&T::default_instance(), t, i));
+        results.push_back(
+            std::make_tuple(&T::default_instance(), t, i, lines[i]));
     }
   }
   return results;
@@ -300,7 +302,8 @@ std::vector<TestParams> GetMessageTestParams(
     auto lines = Split(t);
     for (size_t i = 0; i != lines.size(); ++i) {
       if (lines[i].find("{}") != std::string::npos)
-        results.push_back(std::make_tuple(&T::default_instance(), t, i));
+        results.push_back(
+            std::make_tuple(&T::default_instance(), t, i, lines[i]));
     }
   }
   return results;

From b27caf9f7838cc13358c458626ee38ca623fb989 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Mon, 27 Jan 2020 18:37:11 -0800
Subject: [PATCH 16/24] Reduce number of iterations in some tests

---
 src/mutator_test.cc | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index dd18b6c..1e190aa 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -309,12 +309,13 @@ std::vector<TestParams> GetMessageTestParams(
   return results;
 }
 
-bool Mutate(const protobuf::Message& from, const protobuf::Message& to) {
+bool Mutate(const protobuf::Message& from, const protobuf::Message& to,
+            int iterations = 10000) {
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
   ReducedTestMutator mutator;
   std::unique_ptr<protobuf::Message> message(from.New());
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
-  for (int j = 0; j < 1000000; ++j) {
+  for (int j = 0; j < iterations; ++j) {
     message->CopyFrom(from);
     mutator.Mutate(message.get(), 1000);
     if (MessageDifferencer::Equals(*message, to)) return true;
@@ -327,12 +328,12 @@ bool Mutate(const protobuf::Message& from, const protobuf::Message& to) {
 }
 
 bool CrossOver(const protobuf::Message& from, const protobuf::Message& with,
-               const protobuf::Message& to) {
+               const protobuf::Message& to, int iterations = 10000) {
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
   ReducedTestMutator mutator;
   std::unique_ptr<protobuf::Message> message(from.New());
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
-  for (int j = 0; j < 1000000; ++j) {
+  for (int j = 0; j < iterations; ++j) {
     message->CopyFrom(from);
     mutator.CrossOver(with, message.get(), 1000);
     if (MessageDifferencer::Equals(*message, to)) return true;
@@ -440,8 +441,8 @@ TEST_P(MutatorFieldTest, Initialized) {
 TEST_P(MutatorFieldTest, ChangeField) {
   LoadWithChangedLine(m1_.get(), 0);
   LoadWithChangedLine(m2_.get(), 1);
-  EXPECT_TRUE(Mutate(*m1_, *m2_));
-  EXPECT_TRUE(Mutate(*m2_, *m1_));
+  EXPECT_TRUE(Mutate(*m1_, *m2_, 1000000));
+  EXPECT_TRUE(Mutate(*m2_, *m1_, 1000000));
 }
 
 TEST_P(MutatorFieldTest, CrossOver) {

From 01d1394d2c8f8cbdcee71eb75e2e313b90f75653 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Mon, 27 Jan 2020 18:49:40 -0800
Subject: [PATCH 17/24] Add Any tests for #151

---
 src/mutator_test.cc | 105 ++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 96 insertions(+), 9 deletions(-)

diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 1e190aa..5273f01 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -46,6 +46,17 @@ const char kMessages[] = R"(
     repeated_msg { required_int32: 67 }
     repeated_msg {}
   }
+  any {
+    [type.googleapis.com/protobuf_mutator.Msg] {
+      optional_msg {}
+      repeated_msg {}
+      any {
+        [type.googleapis.com/protobuf_mutator.Msg3.SubMsg] {
+          optional_int64: -5
+        }
+      }
+    }
+  }
 )";
 
 const char kMessagesProto3[] = R"(
@@ -59,6 +70,17 @@ const char kMessagesProto3[] = R"(
     repeated_msg { optional_int32: 67 }
     repeated_msg {}
   }
+  any {
+    [type.googleapis.com/protobuf_mutator.Msg] {
+      optional_msg {}
+      repeated_msg {}
+      any {
+        [type.googleapis.com/protobuf_mutator.Msg3.SubMsg] {
+          optional_int64: -5
+        }
+      }
+    }
+  }
 )";
 
 const char kRequiredFields[] = R"(
@@ -154,6 +176,18 @@ const char kRequiredNestedFields[] = R"(
   }
 )";
 
+const char kRequiredInAnyFields[] = R"(
+  any {
+    [type.googleapis.com/protobuf_mutator.Msg] {
+      required_uint32: 14486213
+      required_uint64: 520229415
+      required_sint64: -6057486163525532641
+      required_string: "qwert"
+      required_bytes: "asdf"
+    }
+  }
+)";
+
 const char kOptionalNestedFields[] = R"(
   optional_int32: 123
   optional_msg {
@@ -176,6 +210,18 @@ const char kOptionalNestedFields[] = R"(
   }
 )";
 
+const char kOptionalInAnyFields[] = R"(
+  any {
+    [type.googleapis.com/protobuf_mutator.Msg] {
+      optional_uint32: 440
+      optional_uint64: 1559
+      optional_sint32: 440615
+      optional_string: "XYZ"
+      optional_enum: ENUM_4
+    }
+  }
+)";
+
 const char kRepeatedNestedFields[] = R"(
   optional_int32: 123
   optional_msg {
@@ -214,6 +260,39 @@ const char kRepeatedNestedFields[] = R"(
   }
 )";
 
+const char kRepeatedInAnyFields[] = R"(
+  any {
+    [type.googleapis.com/protobuf_mutator.Msg] {
+      repeated_double: 1.931778501556e-31
+      repeated_double: 1.26685288449177e-31
+      repeated_float: 4.739759e-41
+      repeated_float: 5.98038e-39
+      repeated_int32: 400201
+      repeated_int32: 673
+      repeated_int64: 104
+      repeated_int64: 52850685
+    }
+  }
+)";
+
+const char kOptionalInDeepAnyFields[] = R"(
+  any {
+    [type.googleapis.com/protobuf_mutator.Msg] {
+      any {
+        [type.googleapis.com/protobuf_mutator.Msg] {
+          any {
+            [type.googleapis.com/protobuf_mutator.Msg] {
+              optional_double: 1.9317850152856e-314
+              optional_sint64: 1743625000076
+              optional_string: "XYZ"
+            }
+          }
+        }
+      }
+    }
+  }
+)";
+
 class TestMutator : public Mutator {
  public:
   explicit TestMutator(bool keep_initialized,
@@ -286,6 +365,7 @@ std::vector<TestParams> GetFieldTestParams(
   for (auto t : tests) {
     auto lines = Split(t);
     for (size_t i = 0; i != lines.size(); ++i) {
+      if (lines[i].find("any {") != std::string::npos) break;
       if (lines[i].find(':') != std::string::npos)
         results.push_back(
             std::make_tuple(&T::default_instance(), t, i, lines[i]));
@@ -301,6 +381,7 @@ std::vector<TestParams> GetMessageTestParams(
   for (auto t : tests) {
     auto lines = Split(t);
     for (size_t i = 0; i != lines.size(); ++i) {
+      if (lines[i].find("any {") != std::string::npos) break;
       if (lines[i].find("{}") != std::string::npos)
         results.push_back(
             std::make_tuple(&T::default_instance(), t, i, lines[i]));
@@ -310,7 +391,7 @@ std::vector<TestParams> GetMessageTestParams(
 }
 
 bool Mutate(const protobuf::Message& from, const protobuf::Message& to,
-            int iterations = 10000) {
+            int iterations = 100000) {
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
   ReducedTestMutator mutator;
   std::unique_ptr<protobuf::Message> message(from.New());
@@ -322,13 +403,13 @@ bool Mutate(const protobuf::Message& from, const protobuf::Message& to,
   }
 
   ADD_FAILURE() << "Failed to get from:\n"
-                << SaveMessageAsText(from) << "\nto:\n"
-                << SaveMessageAsText(to);
+                << from.DebugString() << "\nto:\n"
+                << to.DebugString();
   return false;
 }
 
 bool CrossOver(const protobuf::Message& from, const protobuf::Message& with,
-               const protobuf::Message& to, int iterations = 10000) {
+               const protobuf::Message& to, int iterations = 100000) {
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
   ReducedTestMutator mutator;
   std::unique_ptr<protobuf::Message> message(from.New());
@@ -401,8 +482,10 @@ class MutatorFieldInsDelTest : public MutatorTest {};
 INSTANTIATE_TEST_SUITE_P(Proto2, MutatorFieldInsDelTest,
                          ValuesIn(GetFieldTestParams<Msg>(
                              {kRequiredFields, kOptionalFields, kRepeatedFields,
-                              kRequiredNestedFields, kOptionalNestedFields,
-                              kRepeatedNestedFields})));
+                              kRequiredNestedFields, kRequiredInAnyFields,
+                              kOptionalNestedFields, kOptionalInAnyFields,
+                              kRepeatedNestedFields, kRepeatedInAnyFields,
+                              kOptionalInDeepAnyFields})));
 
 TEST_P(MutatorFieldInsDelTest, DeleteField) {
   LoadMessage(m1_.get());
@@ -424,12 +507,16 @@ class MutatorFieldTest : public MutatorTest {
 INSTANTIATE_TEST_SUITE_P(Proto2, MutatorFieldTest,
                          ValuesIn(GetFieldTestParams<Msg>(
                              {kRequiredFields, kOptionalFields, kRepeatedFields,
-                              kRequiredNestedFields, kOptionalNestedFields,
-                              kRepeatedNestedFields})));
+                              kRequiredNestedFields, kRequiredInAnyFields,
+                              kOptionalNestedFields, kOptionalInAnyFields,
+                              kRepeatedNestedFields, kRepeatedInAnyFields,
+                              kOptionalInDeepAnyFields})));
 INSTANTIATE_TEST_SUITE_P(Proto3, MutatorFieldTest,
                          ValuesIn(GetFieldTestParams<Msg3>(
                              {kOptionalFields, kRepeatedFields,
-                              kOptionalNestedFields, kRepeatedNestedFields})));
+                              kOptionalNestedFields, kOptionalInAnyFields,
+                              kRepeatedNestedFields, kRepeatedInAnyFields,
+                              kOptionalInDeepAnyFields})));
 
 TEST_P(MutatorFieldTest, Initialized) {
   LoadWithoutLine(m1_.get());

From 0e8e7eb2aad6ee8ca8b19d77a7a230a19082a569 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 00:26:35 -0800
Subject: [PATCH 18/24] Combine post processing and initialization It's going
 to be useful for Any support

---
 src/mutator.cc | 140 +++++++++++++++++++++++--------------------------
 src/mutator.h  |   7 ++-
 2 files changed, 68 insertions(+), 79 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index b4a79cb..c0b1409 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -355,6 +355,67 @@ class DataSourceSampler {
   WeightedReservoirSampler<ConstFieldInstance, RandomEngine> sampler_;
 };
 
+class PostProcessing {
+ public:
+  using PostProcessors = std::unordered_multimap<const protobuf::Descriptor*,
+                                                 Mutator::PostProcess>;
+
+  PostProcessing(bool keep_initialized, const PostProcessors& post_processors,
+                 RandomEngine* random)
+      : keep_initialized_(keep_initialized),
+        post_processors_(post_processors),
+        random_(random) {}
+
+  void Run(Message* message, int max_depth) {
+    --max_depth;
+    const Descriptor* descriptor = message->GetDescriptor();
+
+    // Apply custom mutators in nested messages before packing any.
+    const Reflection* reflection = message->GetReflection();
+    for (int i = 0; i < descriptor->field_count(); i++) {
+      const FieldDescriptor* field = descriptor->field(i);
+      if (keep_initialized_ &&
+          (field->is_required() || descriptor->options().map_entry()) &&
+          !reflection->HasField(*message, field)) {
+        CreateDefaultField()(FieldInstance(message, field));
+      }
+
+      if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) continue;
+
+      if (max_depth < 0 && !field->is_required()) {
+        // Clear deep optional fields to avoid stack overflow.
+        reflection->ClearField(message, field);
+        if (field->is_repeated())
+          assert(!reflection->FieldSize(*message, field));
+        else
+          assert(!reflection->HasField(*message, field));
+        continue;
+      }
+
+      if (field->is_repeated()) {
+        const int field_size = reflection->FieldSize(*message, field);
+        for (int j = 0; j < field_size; ++j) {
+          Message* nested_message =
+              reflection->MutableRepeatedMessage(message, field, j);
+          Run(nested_message, max_depth);
+        }
+      } else if (reflection->HasField(*message, field)) {
+        Message* nested_message = reflection->MutableMessage(message, field);
+        Run(nested_message, max_depth);
+      }
+    }
+
+    auto range = post_processors_.equal_range(descriptor);
+    for (auto it = range.first; it != range.second; ++it)
+      it->second(message, (*random_)());
+  }
+
+ private:
+  bool keep_initialized_;
+  const PostProcessors& post_processors_;
+  RandomEngine* random_;
+};
+
 }  // namespace
 
 class FieldMutator {
@@ -479,12 +540,9 @@ void Mutator::Mutate(Message* message, size_t max_size_hint) {
              static_cast<int>(max_size_hint) -
                  static_cast<int>(message->ByteSizeLong()));
 
-  InitializeAndTrim(message, kMaxInitializeDepth);
+  PostProcessing(keep_initialized_, post_processors_, &random_)
+      .Run(message, kMaxInitializeDepth);
   assert(IsInitialized(*message));
-
-  if (!post_processors_.empty()) {
-    ApplyPostProcessing(message);
-  }
 }
 
 void Mutator::RegisterPostProcessor(const Descriptor* desc,
@@ -492,34 +550,6 @@ void Mutator::RegisterPostProcessor(const Descriptor* desc,
   post_processors_.emplace(desc, callback);
 }
 
-void Mutator::ApplyPostProcessing(Message* message) {
-  const Descriptor* descriptor = message->GetDescriptor();
-
-  auto range = post_processors_.equal_range(descriptor);
-  for (auto it = range.first; it != range.second; ++it)
-    it->second(message, random_());
-
-  // Now recursively apply custom mutators.
-  const Reflection* reflection = message->GetReflection();
-  for (int i = 0; i < descriptor->field_count(); i++) {
-    const FieldDescriptor* field = descriptor->field(i);
-    if (field->cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) {
-      continue;
-    }
-    if (field->is_repeated()) {
-      const int field_size = reflection->FieldSize(*message, field);
-      for (int j = 0; j < field_size; ++j) {
-        Message* nested_message =
-            reflection->MutableRepeatedMessage(message, field, j);
-        ApplyPostProcessing(nested_message);
-      }
-    } else if (reflection->HasField(*message, field)) {
-      Message* nested_message = reflection->MutableMessage(message, field);
-      ApplyPostProcessing(nested_message);
-    }
-  }
-}
-
 bool Mutator::MutateImpl(const Message& source, Message* message,
                          bool copy_clone_only, int size_increase_hint) {
   if (size_increase_hint > 0) size_increase_hint /= 2;
@@ -578,49 +608,9 @@ void Mutator::CrossOver(const Message& message1, Message* message2,
   MutateImpl(message1, message2, true, size_increase_hint) ||
       MutateImpl(*message2, message2, true, size_increase_hint);
 
-  InitializeAndTrim(message2, kMaxInitializeDepth);
+  PostProcessing(keep_initialized_, post_processors_, &random_)
+      .Run(message2, kMaxInitializeDepth);
   assert(IsInitialized(*message2));
-
-  if (!post_processors_.empty()) {
-    ApplyPostProcessing(message2);
-  }
-}
-
-void Mutator::InitializeAndTrim(Message* message, int max_depth) {
-  const Descriptor* descriptor = message->GetDescriptor();
-  const Reflection* reflection = message->GetReflection();
-  for (int i = 0; i < descriptor->field_count(); ++i) {
-    const FieldDescriptor* field = descriptor->field(i);
-    if (keep_initialized_ &&
-        (field->is_required() || descriptor->options().map_entry()) &&
-        !reflection->HasField(*message, field)) {
-      CreateDefaultField()(FieldInstance(message, field));
-    }
-
-    if (field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {
-      if (max_depth <= 0 && !field->is_required()) {
-        // Clear deep optional fields to avoid stack overflow.
-        reflection->ClearField(message, field);
-        if (field->is_repeated())
-          assert(!reflection->FieldSize(*message, field));
-        else
-          assert(!reflection->HasField(*message, field));
-        continue;
-      }
-
-      if (field->is_repeated()) {
-        const int field_size = reflection->FieldSize(*message, field);
-        for (int j = 0; j < field_size; ++j) {
-          Message* nested_message =
-              reflection->MutableRepeatedMessage(message, field, j);
-          InitializeAndTrim(nested_message, max_depth - 1);
-        }
-      } else if (reflection->HasField(*message, field)) {
-        Message* nested_message = reflection->MutableMessage(message, field);
-        InitializeAndTrim(nested_message, max_depth - 1);
-      }
-    }
-  }
 }
 
 int32_t Mutator::MutateInt32(int32_t value) { return FlipBit(value, &random_); }
diff --git a/src/mutator.h b/src/mutator.h
index 0bc2f0b..4032067 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -89,18 +89,17 @@ class Mutator {
  private:
   friend class FieldMutator;
   friend class TestMutator;
-  void InitializeAndTrim(protobuf::Message* message, int max_depth);
   bool MutateImpl(const protobuf::Message& source, protobuf::Message* message,
                   bool copy_clone_only, int size_increase_hint);
   std::string MutateUtf8String(const std::string& value,
                                int size_increase_hint);
-  void ApplyPostProcessing(protobuf::Message* message);
   bool IsInitialized(const protobuf::Message& message) const;
   bool keep_initialized_ = true;
   size_t random_to_default_ratio_ = 100;
   RandomEngine random_;
-  std::unordered_multimap<const protobuf::Descriptor*, PostProcess>
-      post_processors_;
+  using PostProcessors =
+      std::unordered_multimap<const protobuf::Descriptor*, PostProcess>;
+  PostProcessors post_processors_;
 };
 
 }  // namespace protobuf_mutator

From 356853a626eda9367b75a2e358d900448553c3e0 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 00:34:12 -0800
Subject: [PATCH 19/24] Move CrossOver next to Mutate

---
 src/mutator.cc | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index c0b1409..226ac9e 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -545,6 +545,18 @@ void Mutator::Mutate(Message* message, size_t max_size_hint) {
   assert(IsInitialized(*message));
 }
 
+void Mutator::CrossOver(const Message& message1, Message* message2,
+                        size_t max_size_hint) {
+  int size_increase_hint = static_cast<int>(max_size_hint) -
+                           static_cast<int>(message2->ByteSizeLong());
+  MutateImpl(message1, message2, true, size_increase_hint) ||
+      MutateImpl(*message2, message2, true, size_increase_hint);
+
+  PostProcessing(keep_initialized_, post_processors_, &random_)
+      .Run(message2, kMaxInitializeDepth);
+  assert(IsInitialized(*message2));
+}
+
 void Mutator::RegisterPostProcessor(const Descriptor* desc,
                                     PostProcess callback) {
   post_processors_.emplace(desc, callback);
@@ -601,18 +613,6 @@ bool Mutator::MutateImpl(const Message& source, Message* message,
   return false;
 }
 
-void Mutator::CrossOver(const Message& message1, Message* message2,
-                        size_t max_size_hint) {
-  int size_increase_hint = static_cast<int>(max_size_hint) -
-                           static_cast<int>(message2->ByteSizeLong());
-  MutateImpl(message1, message2, true, size_increase_hint) ||
-      MutateImpl(*message2, message2, true, size_increase_hint);
-
-  PostProcessing(keep_initialized_, post_processors_, &random_)
-      .Run(message2, kMaxInitializeDepth);
-  assert(IsInitialized(*message2));
-}
-
 int32_t Mutator::MutateInt32(int32_t value) { return FlipBit(value, &random_); }
 
 int64_t Mutator::MutateInt64(int64_t value) { return FlipBit(value, &random_); }

From 7c2363fb13c88a0a6a830ccba113064650b6626b Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 00:40:43 -0800
Subject: [PATCH 20/24] Run InsertField for proto3

---
 src/mutator_test.cc | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 5273f01..2629183 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -493,12 +493,6 @@ TEST_P(MutatorFieldInsDelTest, DeleteField) {
   EXPECT_TRUE(Mutate(*m1_, *m2_));
 }
 
-TEST_P(MutatorFieldInsDelTest, InsertField) {
-  LoadWithoutLine(m1_.get());
-  LoadWithChangedLine(m2_.get(), 0);
-  EXPECT_TRUE(Mutate(*m1_, *m2_));
-}
-
 class MutatorFieldTest : public MutatorTest {
  public:
   template <class Msg>
@@ -525,6 +519,12 @@ TEST_P(MutatorFieldTest, Initialized) {
   EXPECT_TRUE(m1_->IsInitialized());
 }
 
+TEST_P(MutatorFieldTest, InsertField) {
+  LoadWithoutLine(m1_.get());
+  LoadWithChangedLine(m2_.get(), 1);
+  EXPECT_TRUE(Mutate(*m1_, *m2_));
+}
+
 TEST_P(MutatorFieldTest, ChangeField) {
   LoadWithChangedLine(m1_.get(), 0);
   LoadWithChangedLine(m2_.get(), 1);

From b6dc591252dc4eb03293f26fe38b3e93d280e93e Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 00:43:23 -0800
Subject: [PATCH 21/24] Improve field test by preventing copying of top level
 messages

---
 src/mutator_test.cc | 25 ++++++++++++-------------
 1 file changed, 12 insertions(+), 13 deletions(-)

diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index 2629183..ae0f04d 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -547,19 +547,18 @@ void MutatorFieldTest::TestCopyField() {
   LoadWithChangedLine(m1_.get(), 7);
   LoadWithChangedLine(m2_.get(), 0);
 
-  Msg from;
-  from.add_repeated_msg()->CopyFrom(*m1_);
-  from.add_repeated_msg()->CopyFrom(*m2_);
-
-  Msg to;
-  to.add_repeated_msg()->CopyFrom(*m1_);
-  to.add_repeated_msg()->CopyFrom(*m1_);
-  EXPECT_TRUE(Mutate(from, to));
-
-  to.Clear();
-  to.add_repeated_msg()->CopyFrom(*m2_);
-  to.add_repeated_msg()->CopyFrom(*m2_);
-  EXPECT_TRUE(Mutate(from, to));
+  for (int i = 0; i < 2; ++i, m1_.swap(m2_)) {
+    Msg from;
+    from.add_repeated_msg()->CopyFrom(*m1_);
+    from.add_repeated_msg()->CopyFrom(*m2_);
+    from.mutable_repeated_msg(1)->add_repeated_string("repeated_string");
+
+    Msg to;
+    to.add_repeated_msg()->CopyFrom(*m1_);
+    to.add_repeated_msg()->CopyFrom(*m1_);
+    to.mutable_repeated_msg(1)->add_repeated_string("repeated_string");
+    EXPECT_TRUE(Mutate(from, to));
+  }
 }
 
 TEST_P(MutatorFieldTest, CopyField) {

From c364f6fb0f52624c721d3d3b231a1c3a8b3a68f7 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 01:11:23 -0800
Subject: [PATCH 22/24] Accept arrays of messages in MutateImpl For #151

---
 src/mutator.cc | 89 ++++++++++++++++++++++++++++++--------------------
 src/mutator.h  |  3 +-
 2 files changed, 55 insertions(+), 37 deletions(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index 226ac9e..bc2fc2b 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -54,6 +54,9 @@ enum class Mutation : uint8_t {
 
 using MutationBitset = std::bitset<static_cast<size_t>(Mutation::Last)>;
 
+using Messages = std::vector<Message*>;
+using ConstMessages = std::vector<const Message*>;
+
 // Return random integer from [0, count)
 size_t GetRandomIndex(RandomEngine* random, size_t count) {
   assert(count > 0);
@@ -173,16 +176,11 @@ class CanCopyAndDifferentField
 class MutationSampler {
  public:
   MutationSampler(bool keep_initialized, MutationBitset allowed_mutations,
-                  RandomEngine* random, Message* message)
+                  RandomEngine* random)
       : keep_initialized_(keep_initialized),
         allowed_mutations_(allowed_mutations),
         random_(random),
-        sampler_(random) {
-    Sample(message);
-    assert(mutation() != Mutation::None ||
-           !allowed_mutations_[static_cast<size_t>(Mutation::Mutate)] ||
-           message->GetDescriptor()->field_count() == 0);
-  }
+        sampler_(random) {}
 
   // Returns selected field.
   const FieldInstance& field() const { return sampler_.selected().field; }
@@ -190,8 +188,15 @@ class MutationSampler {
   // Returns selected mutation.
   Mutation mutation() const { return sampler_.selected().mutation; }
 
- private:
   void Sample(Message* message) {
+    SampleImpl(message);
+    assert(mutation() != Mutation::None ||
+           !allowed_mutations_[static_cast<size_t>(Mutation::Mutate)] ||
+           message->GetDescriptor()->field_count() == 0);
+  }
+
+ private:
+  void SampleImpl(Message* message) {
     const Descriptor* descriptor = message->GetDescriptor();
     const Reflection* reflection = message->GetReflection();
 
@@ -256,9 +261,9 @@ class MutationSampler {
         if (field->is_repeated()) {
           const int field_size = reflection->FieldSize(*message, field);
           for (int j = 0; j < field_size; ++j)
-            Sample(reflection->MutableRepeatedMessage(message, field, j));
+            SampleImpl(reflection->MutableRepeatedMessage(message, field, j));
         } else if (reflection->HasField(*message, field)) {
-          Sample(reflection->MutableMessage(message, field));
+          SampleImpl(reflection->MutableMessage(message, field));
         }
       }
     }
@@ -289,13 +294,13 @@ class MutationSampler {
 class DataSourceSampler {
  public:
   DataSourceSampler(const ConstFieldInstance& match, RandomEngine* random,
-                    int size_increase_hint, const Message& message)
+                    int size_increase_hint)
       : match_(match),
         random_(random),
         size_increase_hint_(size_increase_hint),
-        sampler_(random) {
-    Sample(message);
-  }
+        sampler_(random) {}
+
+  void Sample(const Message& message) { SampleImpl(message); }
 
   // Returns selected field.
   const ConstFieldInstance& field() const {
@@ -306,7 +311,7 @@ class DataSourceSampler {
   bool IsEmpty() const { return sampler_.IsEmpty(); }
 
  private:
-  void Sample(const Message& message) {
+  void SampleImpl(const Message& message) {
     const Descriptor* descriptor = message.GetDescriptor();
     const Reflection* reflection = message.GetReflection();
 
@@ -317,10 +322,10 @@ class DataSourceSampler {
         if (field->is_repeated()) {
           const int field_size = reflection->FieldSize(message, field);
           for (int j = 0; j < field_size; ++j) {
-            Sample(reflection->GetRepeatedMessage(message, field, j));
+            SampleImpl(reflection->GetRepeatedMessage(message, field, j));
           }
         } else if (reflection->HasField(message, field)) {
-          Sample(reflection->GetMessage(message, field));
+          SampleImpl(reflection->GetMessage(message, field));
         }
       }
 
@@ -357,8 +362,8 @@ class DataSourceSampler {
 
 class PostProcessing {
  public:
-  using PostProcessors = std::unordered_multimap<const protobuf::Descriptor*,
-                                                 Mutator::PostProcess>;
+  using PostProcessors =
+      std::unordered_multimap<const Descriptor*, Mutator::PostProcess>;
 
   PostProcessing(bool keep_initialized, const PostProcessors& post_processors,
                  RandomEngine* random)
@@ -421,12 +426,12 @@ class PostProcessing {
 class FieldMutator {
  public:
   FieldMutator(int size_increase_hint, bool enforce_changes,
-               bool enforce_utf8_strings, const Message& source,
+               bool enforce_utf8_strings, const ConstMessages& sources,
                Mutator* mutator)
       : size_increase_hint_(size_increase_hint),
         enforce_changes_(enforce_changes),
         enforce_utf8_strings_(enforce_utf8_strings),
-        source_(source),
+        sources_(sources),
         mutator_(mutator) {}
 
   void Mutate(int32_t* value) const {
@@ -478,7 +483,8 @@ class FieldMutator {
     assert(*message);
     if (GetRandomBool(mutator_->random(), mutator_->random_to_default_ratio_))
       return;
-    mutator_->MutateImpl(source_, message->get(), false, size_increase_hint_);
+    mutator_->MutateImpl(sources_, {message->get()}, false,
+                         size_increase_hint_);
   }
 
  private:
@@ -498,7 +504,7 @@ class FieldMutator {
   int size_increase_hint_;
   size_t enforce_changes_;
   bool enforce_utf8_strings_;
-  const Message& source_;
+  const ConstMessages& sources_;
   Mutator* mutator_;
 };
 
@@ -507,10 +513,11 @@ namespace {
 struct MutateField : public FieldFunction<MutateField> {
   template <class T>
   void ForType(const FieldInstance& field, int size_increase_hint,
-               const Message& source, Mutator* mutator) const {
+               const ConstMessages& sources, Mutator* mutator) const {
     T value;
     field.Load(&value);
-    FieldMutator(size_increase_hint, true, field.EnforceUtf8(), source, mutator)
+    FieldMutator(size_increase_hint, true, field.EnforceUtf8(), sources,
+                 mutator)
         .Mutate(&value);
     field.Store(value);
   }
@@ -520,12 +527,12 @@ struct CreateField : public FieldFunction<CreateField> {
  public:
   template <class T>
   void ForType(const FieldInstance& field, int size_increase_hint,
-               const Message& source, Mutator* mutator) const {
+               const ConstMessages& sources, Mutator* mutator) const {
     T value;
     field.GetDefault(&value);
     FieldMutator field_mutator(size_increase_hint,
                                false /* defaults could be useful */,
-                               field.EnforceUtf8(), source, mutator);
+                               field.EnforceUtf8(), sources, mutator);
     field_mutator.Mutate(&value);
     field.Create(value);
   }
@@ -536,7 +543,10 @@ struct CreateField : public FieldFunction<CreateField> {
 void Mutator::Seed(uint32_t value) { random_.seed(value); }
 
 void Mutator::Mutate(Message* message, size_t max_size_hint) {
-  MutateImpl(*message, message, false,
+  Messages messages;
+  messages.push_back(message);
+  ConstMessages sources(messages.begin(), messages.end());
+  MutateImpl(sources, messages, false,
              static_cast<int>(max_size_hint) -
                  static_cast<int>(message->ByteSizeLong()));
 
@@ -547,10 +557,13 @@ void Mutator::Mutate(Message* message, size_t max_size_hint) {
 
 void Mutator::CrossOver(const Message& message1, Message* message2,
                         size_t max_size_hint) {
+  Messages messages;
+  messages.push_back(message2);
+  ConstMessages sources;
+  sources.push_back(&message1);
   int size_increase_hint = static_cast<int>(max_size_hint) -
                            static_cast<int>(message2->ByteSizeLong());
-  MutateImpl(message1, message2, true, size_increase_hint) ||
-      MutateImpl(*message2, message2, true, size_increase_hint);
+  MutateImpl(sources, messages, true, size_increase_hint);
 
   PostProcessing(keep_initialized_, post_processors_, &random_)
       .Run(message2, kMaxInitializeDepth);
@@ -562,7 +575,7 @@ void Mutator::RegisterPostProcessor(const Descriptor* desc,
   post_processors_.emplace(desc, callback);
 }
 
-bool Mutator::MutateImpl(const Message& source, Message* message,
+bool Mutator::MutateImpl(const ConstMessages& sources, const Messages& messages,
                          bool copy_clone_only, int size_increase_hint) {
   if (size_increase_hint > 0) size_increase_hint /= 2;
   MutationBitset mutations;
@@ -575,17 +588,19 @@ bool Mutator::MutateImpl(const Message& source, Message* message,
     mutations.set();
   }
   while (mutations.any()) {
-    MutationSampler mutation(keep_initialized_, mutations, &random_, message);
+    MutationSampler mutation(keep_initialized_, mutations, &random_);
+    for (Message* message : messages) mutation.Sample(message);
+
     // Don't try same mutation next time.
     mutations[static_cast<size_t>(mutation.mutation())] = false;
     switch (mutation.mutation()) {
       case Mutation::None:
         return true;
       case Mutation::Add:
-        CreateField()(mutation.field(), size_increase_hint, source, this);
+        CreateField()(mutation.field(), size_increase_hint, sources, this);
         return true;
       case Mutation::Mutate:
-        MutateField()(mutation.field(), size_increase_hint, source, this);
+        MutateField()(mutation.field(), size_increase_hint, sources, this);
         return true;
       case Mutation::Delete:
         DeleteField()(mutation.field());
@@ -593,14 +608,16 @@ bool Mutator::MutateImpl(const Message& source, Message* message,
       case Mutation::Clone: {
         CreateDefaultField()(mutation.field());
         DataSourceSampler source_sampler(mutation.field(), &random_,
-                                         size_increase_hint, source);
+                                         size_increase_hint);
+        for (const Message* source : sources) source_sampler.Sample(*source);
         if (source_sampler.IsEmpty()) return true;  // CreateField is enough.
         CopyField()(source_sampler.field(), mutation.field());
         return true;
       }
       case Mutation::Copy: {
         DataSourceSampler source_sampler(mutation.field(), &random_,
-                                         size_increase_hint, source);
+                                         size_increase_hint);
+        for (const Message* source : sources) source_sampler.Sample(*source);
         if (source_sampler.IsEmpty()) break;
         CopyField()(source_sampler.field(), mutation.field());
         return true;
diff --git a/src/mutator.h b/src/mutator.h
index 4032067..57c7c47 100644
--- a/src/mutator.h
+++ b/src/mutator.h
@@ -89,7 +89,8 @@ class Mutator {
  private:
   friend class FieldMutator;
   friend class TestMutator;
-  bool MutateImpl(const protobuf::Message& source, protobuf::Message* message,
+  bool MutateImpl(const std::vector<const protobuf::Message*>& sources,
+                  const std::vector<protobuf::Message*>& messages,
                   bool copy_clone_only, int size_increase_hint);
   std::string MutateUtf8String(const std::string& value,
                                int size_increase_hint);

From c8391c996a33cc733a233c8ca7141376655ab828 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 01:22:21 -0800
Subject: [PATCH 23/24] Implement Any support Fixes #151

---
 examples/libfuzzer/libfuzzer_bin_example.cc  |  23 +++-
 examples/libfuzzer/libfuzzer_example.cc      |  23 +++-
 examples/libfuzzer/libfuzzer_example_test.cc |   4 +-
 port/protobuf.h                              |   1 +
 src/mutator.cc                               | 109 ++++++++++++++++++-
 src/mutator_test.cc                          |   4 +-
 6 files changed, 151 insertions(+), 13 deletions(-)

diff --git a/examples/libfuzzer/libfuzzer_bin_example.cc b/examples/libfuzzer/libfuzzer_bin_example.cc
index dae46da..560bcb3 100644
--- a/examples/libfuzzer/libfuzzer_bin_example.cc
+++ b/examples/libfuzzer/libfuzzer_bin_example.cc
@@ -15,6 +15,7 @@
 #include <cmath>
 
 #include "examples/libfuzzer/libfuzzer_example.pb.h"
+#include "port/protobuf.h"
 #include "src/libfuzzer/libfuzzer_macro.h"
 
 protobuf_mutator::protobuf::LogSilencer log_silincer;
@@ -26,15 +27,35 @@ DEFINE_BINARY_PROTO_FUZZER(const libfuzzer_example::Msg& message) {
           message->set_optional_uint64(
               std::hash<std::string>{}(message->optional_string()));
         }
+
+        if (message->has_any()) {
+          auto* any = message->mutable_any();
+
+          // Guide mutator to usefull 'Any' types.
+          static const char* const expected_types[] = {
+              "type.googleapis.com/google.protobuf.DescriptorProto",
+              "type.googleapis.com/google.protobuf.FileDescriptorProto",
+          };
+
+          if (!std::count(std::begin(expected_types), std::end(expected_types),
+                          any->type_url())) {
+            const size_t num =
+                (std::end(expected_types) - std::begin(expected_types));
+            any->set_type_url(expected_types[seed % num]);
+          }
+        }
       }};
 
+  protobuf_mutator::protobuf::FileDescriptorProto file;
+
   // Emulate a bug.
   if (message.optional_uint64() ==
           std::hash<std::string>{}(message.optional_string()) &&
       message.optional_string() == "abcdefghijklmnopqrstuvwxyz" &&
       !std::isnan(message.optional_float()) &&
       std::fabs(message.optional_float()) > 1000 &&
-      std::fabs(message.optional_float()) < 1E10) {
+      message.any().UnpackTo(&file) && !file.name().empty()) {
+    std::cerr << message.DebugString() << "\n";
     abort();
   }
 }
diff --git a/examples/libfuzzer/libfuzzer_example.cc b/examples/libfuzzer/libfuzzer_example.cc
index 1520840..6eab362 100644
--- a/examples/libfuzzer/libfuzzer_example.cc
+++ b/examples/libfuzzer/libfuzzer_example.cc
@@ -15,6 +15,7 @@
 #include <cmath>
 
 #include "examples/libfuzzer/libfuzzer_example.pb.h"
+#include "port/protobuf.h"
 #include "src/libfuzzer/libfuzzer_macro.h"
 
 protobuf_mutator::protobuf::LogSilencer log_silincer;
@@ -26,15 +27,35 @@ DEFINE_PROTO_FUZZER(const libfuzzer_example::Msg& message) {
           message->set_optional_uint64(
               std::hash<std::string>{}(message->optional_string()));
         }
+
+        if (message->has_any()) {
+          auto* any = message->mutable_any();
+
+          // Guide mutator to usefull 'Any' types.
+          static const char* const expected_types[] = {
+              "type.googleapis.com/google.protobuf.DescriptorProto",
+              "type.googleapis.com/google.protobuf.FileDescriptorProto",
+          };
+
+          if (!std::count(std::begin(expected_types), std::end(expected_types),
+                          any->type_url())) {
+            const size_t num =
+                (std::end(expected_types) - std::begin(expected_types));
+            any->set_type_url(expected_types[seed % num]);
+          }
+        }
       }};
 
+  protobuf_mutator::protobuf::FileDescriptorProto file;
+
   // Emulate a bug.
   if (message.optional_uint64() ==
           std::hash<std::string>{}(message.optional_string()) &&
       message.optional_string() == "abcdefghijklmnopqrstuvwxyz" &&
       !std::isnan(message.optional_float()) &&
       std::fabs(message.optional_float()) > 1000 &&
-      std::fabs(message.optional_float()) < 1E10) {
+      message.any().UnpackTo(&file) && !file.name().empty()) {
+    std::cerr << message.DebugString() << "\n";
     abort();
   }
 }
diff --git a/examples/libfuzzer/libfuzzer_example_test.cc b/examples/libfuzzer/libfuzzer_example_test.cc
index e871d59..2c6fd8c 100644
--- a/examples/libfuzzer/libfuzzer_example_test.cc
+++ b/examples/libfuzzer/libfuzzer_example_test.cc
@@ -25,12 +25,12 @@ int GetError(int exit_code) { return WSTOPSIG(exit_code); }
 
 TEST_F(LibFuzzerExampleTest, Text) {
   EXPECT_EQ(kDefaultLibFuzzerError,
-            GetError(RunFuzzer("libfuzzer_example", 150, 10000000)));
+            GetError(RunFuzzer("libfuzzer_example", 1000, 10000000)));
 }
 
 TEST_F(LibFuzzerExampleTest, Binary) {
   EXPECT_EQ(kDefaultLibFuzzerError,
-            GetError(RunFuzzer("libfuzzer_bin_example", 150, 10000000)));
+            GetError(RunFuzzer("libfuzzer_bin_example", 1000, 10000000)));
 }
 
 }  // namespace
diff --git a/port/protobuf.h b/port/protobuf.h
index e70d42d..04e0620 100644
--- a/port/protobuf.h
+++ b/port/protobuf.h
@@ -17,6 +17,7 @@
 
 #include <string>
 
+#include "google/protobuf/any.pb.h"
 #include "google/protobuf/descriptor.pb.h"
 #include "google/protobuf/message.h"
 #include "google/protobuf/text_format.h"
diff --git a/src/mutator.cc b/src/mutator.cc
index bc2fc2b..11254ac 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -17,6 +17,7 @@
 #include <algorithm>
 #include <bitset>
 #include <map>
+#include <memory>
 #include <random>
 #include <string>
 #include <vector>
@@ -27,6 +28,7 @@
 
 namespace protobuf_mutator {
 
+using protobuf::Any;
 using protobuf::Descriptor;
 using protobuf::FieldDescriptor;
 using protobuf::FileDescriptor;
@@ -360,15 +362,76 @@ class DataSourceSampler {
   WeightedReservoirSampler<ConstFieldInstance, RandomEngine> sampler_;
 };
 
+using UnpackedAny =
+    std::unordered_map<const Message*, std::unique_ptr<Message>>;
+
+const Descriptor* GetAnyTypeDescriptor(const Any& any) {
+  std::string type_name;
+  if (!Any::ParseAnyTypeUrl(any.type_url(), &type_name)) return nullptr;
+  return any.descriptor()->file()->pool()->FindMessageTypeByName(type_name);
+}
+
+std::unique_ptr<Message> UnpackAny(const Any& any) {
+  const Descriptor* desc = GetAnyTypeDescriptor(any);
+  if (!desc) return {};
+  std::unique_ptr<Message> message(
+      any.GetReflection()->GetMessageFactory()->GetPrototype(desc)->New());
+  message->ParsePartialFromString(any.value());
+  return message;
+}
+
+const Any* CastToAny(const Message* message) {
+  return Any::GetDescriptor() == message->GetDescriptor()
+             ? static_cast<const Any*>(message)
+             : nullptr;
+}
+
+Any* CastToAny(Message* message) {
+  return Any::GetDescriptor() == message->GetDescriptor()
+             ? static_cast<Any*>(message)
+             : nullptr;
+}
+
+std::unique_ptr<Message> UnpackIfAny(const Message& message) {
+  if (const Any* any = CastToAny(&message)) return UnpackAny(*any);
+  return {};
+}
+
+void UnpackAny(const Message& message, UnpackedAny* result) {
+  if (std::unique_ptr<Message> any = UnpackIfAny(message)) {
+    UnpackAny(*any, result);
+    result->emplace(&message, std::move(any));
+    return;
+  }
+
+  const Descriptor* descriptor = message.GetDescriptor();
+  const Reflection* reflection = message.GetReflection();
+
+  for (int i = 0; i < descriptor->field_count(); ++i) {
+    const FieldDescriptor* field = descriptor->field(i);
+    if (field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {
+      if (field->is_repeated()) {
+        const int field_size = reflection->FieldSize(message, field);
+        for (int j = 0; j < field_size; ++j) {
+          UnpackAny(reflection->GetRepeatedMessage(message, field, j), result);
+        }
+      } else if (reflection->HasField(message, field)) {
+        UnpackAny(reflection->GetMessage(message, field), result);
+      }
+    }
+  }
+}
+
 class PostProcessing {
  public:
   using PostProcessors =
       std::unordered_multimap<const Descriptor*, Mutator::PostProcess>;
 
   PostProcessing(bool keep_initialized, const PostProcessors& post_processors,
-                 RandomEngine* random)
+                 UnpackedAny& any, RandomEngine* random)
       : keep_initialized_(keep_initialized),
         post_processors_(post_processors),
+        any_(any),
         random_(random) {}
 
   void Run(Message* message, int max_depth) {
@@ -410,6 +473,22 @@ class PostProcessing {
       }
     }
 
+    if (Any* any = CastToAny(message)) {
+      if (max_depth < 0) {
+        // Clear deep Any fields to avoid stack overflow.
+        any->Clear();
+      } else {
+        auto It = any_.find(message);
+        if (It != any_.end()) {
+          Run(It->second.get(), max_depth);
+          // assert(GetAnyTypeDescriptor(*any) == It->second->GetDescriptor());
+          // if (GetAnyTypeDescriptor(*any) != It->second->GetDescriptor()) {}
+          It->second->SerializePartialToString(any->mutable_value());
+        }
+      }
+    }
+
+    // Call user callback after message trimmed, initialized and packed.
     auto range = post_processors_.equal_range(descriptor);
     for (auto it = range.first; it != range.second; ++it)
       it->second(message, (*random_)());
@@ -418,6 +497,7 @@ class PostProcessing {
  private:
   bool keep_initialized_;
   const PostProcessors& post_processors_;
+  UnpackedAny& any_;
   RandomEngine* random_;
 };
 
@@ -543,29 +623,46 @@ struct CreateField : public FieldFunction<CreateField> {
 void Mutator::Seed(uint32_t value) { random_.seed(value); }
 
 void Mutator::Mutate(Message* message, size_t max_size_hint) {
+  UnpackedAny any;
+  UnpackAny(*message, &any);
+
   Messages messages;
+  messages.reserve(any.size() + 1);
   messages.push_back(message);
+  for (const auto& kv : any) messages.push_back(kv.second.get());
+
   ConstMessages sources(messages.begin(), messages.end());
   MutateImpl(sources, messages, false,
              static_cast<int>(max_size_hint) -
                  static_cast<int>(message->ByteSizeLong()));
 
-  PostProcessing(keep_initialized_, post_processors_, &random_)
+  PostProcessing(keep_initialized_, post_processors_, any, &random_)
       .Run(message, kMaxInitializeDepth);
   assert(IsInitialized(*message));
 }
 
 void Mutator::CrossOver(const Message& message1, Message* message2,
                         size_t max_size_hint) {
+  UnpackedAny any;
+  UnpackAny(*message2, &any);
+
   Messages messages;
+  messages.reserve(any.size() + 1);
   messages.push_back(message2);
+  for (auto& kv : any) messages.push_back(kv.second.get());
+
+  UnpackAny(message1, &any);
+
   ConstMessages sources;
+  sources.reserve(any.size() + 1);
   sources.push_back(&message1);
-  int size_increase_hint = static_cast<int>(max_size_hint) -
-                           static_cast<int>(message2->ByteSizeLong());
-  MutateImpl(sources, messages, true, size_increase_hint);
+  for (const auto& kv : any) sources.push_back(kv.second.get());
+
+  MutateImpl(sources, messages, true,
+             static_cast<int>(max_size_hint) -
+                 static_cast<int>(message2->ByteSizeLong()));
 
-  PostProcessing(keep_initialized_, post_processors_, &random_)
+  PostProcessing(keep_initialized_, post_processors_, any, &random_)
       .Run(message2, kMaxInitializeDepth);
   assert(IsInitialized(*message2));
 }
diff --git a/src/mutator_test.cc b/src/mutator_test.cc
index ae0f04d..0fcf2ce 100644
--- a/src/mutator_test.cc
+++ b/src/mutator_test.cc
@@ -365,7 +365,6 @@ std::vector<TestParams> GetFieldTestParams(
   for (auto t : tests) {
     auto lines = Split(t);
     for (size_t i = 0; i != lines.size(); ++i) {
-      if (lines[i].find("any {") != std::string::npos) break;
       if (lines[i].find(':') != std::string::npos)
         results.push_back(
             std::make_tuple(&T::default_instance(), t, i, lines[i]));
@@ -381,7 +380,6 @@ std::vector<TestParams> GetMessageTestParams(
   for (auto t : tests) {
     auto lines = Split(t);
     for (size_t i = 0; i != lines.size(); ++i) {
-      if (lines[i].find("any {") != std::string::npos) break;
       if (lines[i].find("{}") != std::string::npos)
         results.push_back(
             std::make_tuple(&T::default_instance(), t, i, lines[i]));
@@ -398,7 +396,7 @@ bool Mutate(const protobuf::Message& from, const protobuf::Message& to,
   EXPECT_FALSE(MessageDifferencer::Equals(from, to));
   for (int j = 0; j < iterations; ++j) {
     message->CopyFrom(from);
-    mutator.Mutate(message.get(), 1000);
+    mutator.Mutate(message.get(), 1500);
     if (MessageDifferencer::Equals(*message, to)) return true;
   }
 

From b43126ccb27d16b0af5376e7b4e445000ad00101 Mon Sep 17 00:00:00 2001
From: Vitaly Buka <vitalybuka@google.com>
Date: Wed, 29 Jan 2020 01:23:42 -0800
Subject: [PATCH 24/24] Remove unnececary size_increase_hint adjustment

---
 src/mutator.cc | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/mutator.cc b/src/mutator.cc
index 11254ac..574c428 100644
--- a/src/mutator.cc
+++ b/src/mutator.cc
@@ -674,7 +674,6 @@ void Mutator::RegisterPostProcessor(const Descriptor* desc,
 
 bool Mutator::MutateImpl(const ConstMessages& sources, const Messages& messages,
                          bool copy_clone_only, int size_increase_hint) {
-  if (size_increase_hint > 0) size_increase_hint /= 2;
   MutationBitset mutations;
   if (copy_clone_only) {
     mutations[static_cast<size_t>(Mutation::Copy)] = true;
