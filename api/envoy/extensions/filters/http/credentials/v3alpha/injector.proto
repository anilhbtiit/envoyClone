syntax = "proto3";

package envoy.extensions.filters.http.credentials.v3alpha;

import "envoy/config/core/v3/http_uri.proto";
import "envoy/extensions/transport_sockets/tls/v3/secret.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.credentials.v3alpha";
option java_outer_classname = "InjectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/credentials/v3alpha;credentialsv3alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Credentials Injector]
// Credentials Injector :ref:`configuration overview <config_http_filters_credentials>`.
// [#extension: envoy.filters.http.credentials]
//

// Filter config.
message Injector {
  // Credential to inject into proxied requests.
  Credential credential = 1 [(validate.rules).message = {required: true}];
}

// Credential to inject into proxied requests.
//
// [#next-free-field: 5]
message Credential {
  oneof credential_type {
    option (validate.required) = true;

    // Basic Auth Credential to inject.
    BasicAuthCredential basic = 1;

    // Bearer Token Credential to inject.
    BearerTokenCredential bearer = 2;

    // OAuth2 Credential to inject.
    OAuth2Credential oauth2 = 3;
  }
}

// Basic Auth Credential to inject into proxied requests.
//
// RFC https://www.rfc-editor.org/rfc/rfc7617
//
// [#next-free-field: 3]
message BasicAuthCredential {
  // User name.
  SecretValue username = 1 [(validate.rules).message = {required: true}];
  // User password.
  SecretValue password = 2 [(validate.rules).message = {required: true}];
}

// Bearer Token Credential to inject into proxied requests.
//
// [#next-free-field: 2]
message BearerTokenCredential {
  // Token value, e.g. JWT token.
  SecretValue token = 1 [(validate.rules).message = {required: true}];
}

// OAuth2 Credential to inject into proxied requests.
//
// [#next-free-field: 4]
message OAuth2Credential {
  // Endpoint on the authorization server to retrieve the access token from.
  // OAuth RFC https://www.rfc-editor.org/rfc/rfc6749#section-3.2
  config.core.v3.HttpUri token_endpoint = 1 [(validate.rules).message = {required: true}];

  // Optional list of OAuth scopes to be claimed in the authorization request.
  // OAuth RFC https://www.rfc-editor.org/rfc/rfc6749#section-4.4.2
  repeated string scopes = 2;

  // Credentials to authenticate client to the authorization server.
  // OAuth RFC https://www.rfc-editor.org/rfc/rfc6749#section-2.3
  message ClientCredentials {
    // Client ID.
    // OAuth RFC https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1
    SecretValue client_id = 1 [(validate.rules).message = {required: true}];
    // Client secret.
    // OAuth RFC https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1
    SecretValue client_secret = 2 [(validate.rules).message = {required: true}];
  }

  oneof flow_type {
    option (validate.required) = true;

    // Client Credentials Grant.
    // OAuth RFC https://www.rfc-editor.org/rfc/rfc6749#section-4.4
    ClientCredentials client_credentials = 3 [(validate.rules).message = {required: true}];
  }
}

// SecretValue provides a security sensitive value.
//
// [#next-free-field: 2]
message SecretValue {
  oneof value_type {
    option (validate.required) = true;

    // Security sensitive value fetched via SDS API.
    transport_sockets.tls.v3.SdsSecretConfig secret = 1
        [(validate.rules).message = {required: true}];
  }
}
