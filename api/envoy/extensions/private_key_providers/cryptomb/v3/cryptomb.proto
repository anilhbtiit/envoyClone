syntax = "proto3";

package envoy.extensions.private_key_providers.cryptomb.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.private_key_providers.cryptomb.v3";
option java_outer_classname = "CryptombProto";
option java_multiple_files = true;
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: CryptoMb private key provider]
// [#extension: envoy.private_key_providers.cryptomb]

// An CryptoMbPrivateKeyMethodConfig message specifies how the CryptoMb private key
// provider is configured. The private key provider provides SIMD processing of
// ECDSA sign operations and RSA sign and decrypt operations. It works by
// gathering the operations into a worker-thread specific queue, and processing
// the queue using ipp-crypto library when the queue is full or when a timer
// expires.
message CryptoMbPrivateKeyMethodConfig {
  // Private key to use in the private key provider. If set to private_key_file,
  // the value needs to be set to a path to proper private key file. If set to
  // inline_private_key, the value needs to be the private key string in PEM
  // format.
  oneof key_type {
    string private_key_file = 1;

    string inline_private_key = 2;
  }

  // How long to wait until the per-thread processing queue should be processed
  // (in microseconds). If the processing queue gets full (eight sign or decrypt
  // requests are received) it is processed immediately. However, if the queue
  // is not filled before the delay has expired, the requests already in the
  // queue are processed, even if the queue is not full. In effect, this value
  // controls the balance between latency and throughput.
  uint32 poll_delay = 3;
}
