syntax = "proto3";

package envoy.extensions.filters.http.file_system_buffer.v3;

import "envoy/extensions/common/async_files/v3/async_file_manager.proto";

import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.file_system_buffer.v3";
option java_outer_classname = "FileSystemBufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/file_system_buffer/v3;file_system_bufferv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#not-implemented-hide:]
// The behavior of the filter for a stream.
// [#next-free-field: 6]
message BufferBehavior {
  oneof behavior {
    option (validate.required) = true;

    // Don't inject ``content-length`` header.
    // Output immediately, buffer only if output is slower than input.
    bool stream_when_possible = 1 [(validate.rules).bool = {const: true}];

    // Never buffer, do nothing.
    bool bypass = 2 [(validate.rules).bool = {const: true}];

    // If ``content-length`` is not present, buffer the entire input,
    // inject ``content-length`` header, then output.
    // If ``content-length`` is already present, act like ``stream_when_possible``.
    bool inject_content_length_if_necessary = 3 [(validate.rules).bool = {const: true}];

    // Always buffer the entire input, and inject ``content-length``,
    // overwriting any provided content-length header.
    bool fully_buffer_and_always_inject_content_length = 4 [(validate.rules).bool = {const: true}];

    // Always buffer the entire input, do not modify ``content-length``.
    bool fully_buffer = 5 [(validate.rules).bool = {const: true}];
  }
}

// [#not-implemented-hide:]
// The configuration for one direction of the filter behavior.
message StreamConfig {
  // Whether to bypass / stream / fully buffer / etc.
  // If unset in route, vhost and listener config, the default is ``stream_when_possible``.
  BufferBehavior behavior = 1;

  // The amount stored in the memory buffer before buffering to disk.
  // If unset in route, vhost and listener config, defaults to a hardcoded value
  // ``default_memory_buffer_bytes_limit`` == 1024*1024
  google.protobuf.UInt64Value memory_buffer_bytes_limit = 2;

  // The maximum storage (excluding memory) to be buffered in this filter.
  // If unset in route, vhost and listener config, defaults to a hardcoded value
  // ``default_storage_buffer_bytes_limit`` == 32*1024*1024
  google.protobuf.UInt64Value storage_buffer_bytes_limit = 3;

  // The maximum amount that can be queued for writing to storage, above which the
  // source is requested to pause. If unset, defaults to the same value as
  // ``memory_buffer_bytes_limit``.
  //
  // For example, assuming the recipient is not consuming data at all, if
  // ``memory_buffer_bytes_limit`` was 32*1024, and ``storage_buffer_queue_high_watermark_bytes``
  // was 64*1024, and the filesystem is backed up so writes are not occurring promptly,
  // then:
  // * Any request less than 32*1024 will eventually pass through without ever attempting
  //   to write to disk.
  // * Any request with over 32*1024 buffered will start trying to write to disk.
  //   * If it reaches (32+64)*1024 buffered and not yet written to disk, a high
  //     watermark signal is sent to the source.
  // * Any stream whose total size exceeds
  //   ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
  //   (Note, if the recipient *is* consuming data then it is possible for such an
  //   oversized request to pass through the buffer filter, provided the recipient
  //   isn't consuming data too slowly.)
  //
  // The low watermark signal is sent when the memory buffer is at size
  //  ``memory_buffer_bytes_limit + (storage_buffer_bytes_limit / 2)``.
  google.protobuf.UInt64Value storage_buffer_queue_high_watermark_bytes = 4;
}

// [#not-implemented-hide:]
// Configuration for file system buffer filter.
//
// Route-specific configs override only the fields they explicitly include; unset
// fields inherit from the vhost or listener-level config, or, if never set,
// and not required, use a default value.
message FileSystemBufferFilterConfig {
  // A configuration for an AsyncFileManager.
  //
  // If unspecified in route, vhost and listener, an exception will be thrown.
  common.async_files.v3.AsyncFileManagerConfig manager_config = 1;

  // An optional path to which the unlinked files should be written - this may
  // determine which physical storage device will be used.
  //
  // If unspecified in route, vhost and listener, will use the environment variable
  // ``TMPDIR``, or, if that's unset, will use ``/tmp``.
  google.protobuf.StringValue storage_buffer_path = 2;

  // Optional configuration for how to buffer (or not) requests.
  // See ``StreamConfig`` definition for defaults.
  StreamConfig request = 3;

  // Optional configuration for how to buffer (or not) responses.
  // See ``StreamConfig`` definition for defaults.
  StreamConfig response = 4;
}
